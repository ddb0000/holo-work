This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
docs/
  figma/
    jam/
      holo.work — agente (heurística v1).jam
      holo.work — agente (heurística v1).jam:Zone.Identifier
      holo.work — agente (heurística v1).pdf:Zone.Identifier
      holo.work — agente (heurística v1).png:Zone.Identifier
      holo.work — arquitetura.jam
      holo.work — arquitetura.jam:Zone.Identifier
      holo.work — arquitetura.pdf:Zone.Identifier
      holo.work — arquitetura.png:Zone.Identifier
      holo.work — deploy.jam
      holo.work — deploy.jam:Zone.Identifier
      holo.work — deploy.pdf:Zone.Identifier
      holo.work — deploy.png:Zone.Identifier
      holo.work — endpoints.jam
      holo.work — endpoints.jam:Zone.Identifier
      holo.work — endpoints.pdf:Zone.Identifier
      holo.work — endpoints.png:Zone.Identifier
      holo.work — estados de presença.jam
      holo.work — estados de presença.jam:Zone.Identifier
      holo.work — estados de presença.pdf:Zone.Identifier
      holo.work — estados de presença.png:Zone.Identifier
      holo.work — fluxo principal.jam
      holo.work — fluxo principal.jam:Zone.Identifier
      holo.work — fluxo principal.pdf:Zone.Identifier
      holo.work — fluxo principal.png:Zone.Identifier
      holo.work — ingestão iot.jam
      holo.work — ingestão iot.jam:Zone.Identifier
      holo.work — ingestão iot.pdf:Zone.Identifier
      holo.work — ingestão iot.png:Zone.Identifier
    pdf/
      holo.work — agente (heurística v1).pdf
      holo.work — arquitetura.pdf
      holo.work — deploy.pdf
      holo.work — endpoints.pdf
      holo.work — estados de presença.pdf
      holo.work — fluxo principal.pdf
      holo.work — ingestão iot.pdf
    png/
      holo.work — agente (heurística v1).png
      holo.work — arquitetura.png
      holo.work — deploy.png
      holo.work — endpoints.png
      holo.work — estados de presença.png
      holo.work — fluxo principal.png
      holo.work — ingestão iot.png
  mermaid/
    agent.mmd
    arq.mmd
    deploy.mmd
    endpoints.mmd
    erd.mmd
    flow.mmd
    iot.mmd
    states.mmd
  DEPLOY.md
  e2e.sh
  ENV.md
  FIAP_PACKAGE.md
  PDF-Turing-HoloWork-GS2-2025.pdf
  pitch-script.md
  PRD.md
  todo.md
scripts/
  iot_sim.py
sql/
  schema.sql
  seed.sql
ui/
  css/
    style.css
  js/
    admin.js
    api.js
    index.js
    room.js
  admin.html
  index.html
  room.html
worker/
  src/
    access.ts
    agent.ts
    assets.ts
    auth.ts
    db.ts
    index.ts
    iot.ts
    kv.ts
    rooms.ts
    types.ts
    utils.ts
  test/
    agent.test.ts
    auth.test.ts
  .dev.vars
  wrangler.toml
.editorconfig
.gitignore
AGENTS.md
CHANGELOG.md
LICENSE
p.md
package.json
README.md
tsconfig.json
```

# Files

## File: docs/figma/jam/holo.work — agente (heurística v1).jam:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: docs/figma/jam/holo.work — agente (heurística v1).pdf:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: docs/figma/jam/holo.work — agente (heurística v1).png:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: docs/figma/jam/holo.work — arquitetura.jam:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: docs/figma/jam/holo.work — arquitetura.pdf:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: docs/figma/jam/holo.work — arquitetura.png:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: docs/figma/jam/holo.work — deploy.jam:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: docs/figma/jam/holo.work — deploy.pdf:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: docs/figma/jam/holo.work — deploy.png:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: docs/figma/jam/holo.work — endpoints.jam:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: docs/figma/jam/holo.work — endpoints.pdf:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: docs/figma/jam/holo.work — endpoints.png:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: docs/figma/jam/holo.work — estados de presença.jam:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: docs/figma/jam/holo.work — estados de presença.pdf:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: docs/figma/jam/holo.work — estados de presença.png:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: docs/figma/jam/holo.work — fluxo principal.jam:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: docs/figma/jam/holo.work — fluxo principal.pdf:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: docs/figma/jam/holo.work — fluxo principal.png:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: docs/figma/jam/holo.work — ingestão iot.jam:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: docs/figma/jam/holo.work — ingestão iot.pdf:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: docs/figma/jam/holo.work — ingestão iot.png:Zone.Identifier
````
[ZoneTransfer]
ZoneId=3
HostUrl=about:internet
````

## File: worker/src/assets.ts
````typescript
export const routes = (app: any) => {
  app.get('/api/assets/avatar', async (c: any) => {
    const seed = (c.req.query('seed') || 'seed').toString()
    const s = Math.min(1024, Math.max(16, parseInt(c.req.query('s') || '128')))
    let h = 2166136261
    for (let i=0;i<seed.length;i++) { h ^= seed.charCodeAt(i); h += (h<<1)+(h<<4)+(h<<7)+(h<<8)+(h<<24) }
    const rnd = () => { h ^= h<<13; h ^= h>>>17; h ^= h<<5; return ((h>>>0)%1000)/1000 }
    const n = 8, px = Math.floor(s/n)
    const palette = ['#0d0d0d','#f5f5f5',`hsl(${Math.floor(rnd()*360)} 70% 55%)`, `hsl(${Math.floor(rnd()*360)} 70% 45%)`]
    let cells = ''
    for (let y=0;y<n;y++){
      for (let x=0;x<Math.ceil(n/2);x++){
        const v = rnd()
        const cidx = v<0.15?0: v<0.3?1: v<0.65?2:3
        const col = palette[cidx]
        const xx = x*px, xx2 = (n-1-x)*px, yy=y*px
        cells += `<rect x="${xx}" y="${yy}" width="${px}" height="${px}" fill="${col}"/>`
        if (x!==n-1-x) cells += `<rect x="${xx2}" y="${yy}" width="${px}" height="${px}" fill="${col}"/>`
      }
    }
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${s}" height="${s}" shape-rendering="crispEdges" viewBox="0 0 ${s} ${s}"><rect width="100%" height="100%" fill="#111"/>${cells}</svg>`
    return new Response(svg, {headers:{'content-type':'image/svg+xml','cache-control':'public, max-age=604800'}})
  })
}
````

## File: docs/mermaid/agent.mmd
````
%% regra do agente — decisão simplificada
flowchart TD
  R[inputs:\nlatest readings\n+ recent checkins] --> N{noise_db > 65\nAND energy < 3?}
  N -- yes --> S1[prompt: mover para sala com menor ruído]
  N -- no --> T{t_c > 27\nAND mood <= 2?}
  T -- yes --> S2[prompt: pausa 5min + água]
  T -- no --> L{lux < 200?}
  L -- yes --> S3[note: ajustar iluminação]
  L -- no --> P{2 users focus >30min\nmesmo room e tasks relacionadas?}
  P -- yes --> S4[sugerir pairing]
  P -- no --> SX[sem sugestão]
````

## File: docs/mermaid/arq.mmd
````
%% arquitetura — visão macro
flowchart LR
  subgraph client["ui (pwa html/css/js)"]
    A[login\nrooms map\nchat/tasks\ncheck-ins]
    SW[service worker\ncache + offline]
  end

  subgraph edge["cloudflare"]
    B[api worker (ts)\nrest + jwt + rate limit]
    KV[(kv\nsessions/rate/agent-cache)]
    D1[(d1 sqlite)]
  end

  subgraph iot["iot_sim (python)"]
    IOT[periodic POST\n/readings ingest]
  end

  A <--->|fetch /api/*| B
  SW --- A
  B <--> D1
  B <--> KV
  IOT -->|X-Device-Secret| B
````

## File: docs/mermaid/deploy.mmd
````
%% deploy — visão mínima
flowchart LR
  DEV[dev machine] -->|wrangler dev| EDGE[worker (local)]
  DEV -->|wrangler d1 execute| D1L[(d1 local)]
  DEV -->|wrangler kv:key put|get| KVL[(kv local)]
  DEV -->|wrangler deploy| CF[worker (prod)]
  CF --> D1P[(d1 prod)]
  CF --> KVP[(kv prod)]
  IOTSIM[iot_sim] --> CF
````

## File: docs/mermaid/endpoints.mmd
````
%% mapa de endpoints — agrupados
graph TD
  subgraph auth
    A1[POST /auth/register]
    A2[POST /auth/login]
    A3[GET /auth/me]
  end
  subgraph rooms
    R1[GET /rooms]
    R2[POST /rooms (admin)]
    R3[GET /rooms/:id]
    R4[POST /rooms/:id/join]
  end
  subgraph messages
    M1[GET /rooms/:id/messages]
    M2[POST /rooms/:id/messages]
  end
  subgraph tasks
    T1[GET /rooms/:id/tasks]
    T2[POST /rooms/:id/tasks]
    T3[PUT /tasks/:id]
  end
  subgraph checkins
    C1[POST /rooms/:id/checkins]
    C2[GET /rooms/:id/checkins]
  end
  subgraph iot
    D1_[POST /devices (admin)]
    I1[POST /iot/ingest]
    I2[GET /rooms/:id/readings]
  end
  subgraph agent
    G1[GET /rooms/:id/suggestions]
  end
````

## File: docs/mermaid/erd.mmd
````
%% erd — d1/sqlite
erDiagram
  USERS {
    text id PK
    text email UK
    text pass_hash
    text role
    integer created_at
  }

  ROOMS {
    text id PK
    text name
    text slug UK
    text map_seed
    integer created_at
  }

  ROOM_MEMBERS {
    text user_id FK
    text room_id FK
    integer joined_at
  }

  MESSAGES {
    text id PK
    text room_id FK
    text user_id FK
    text body
    integer created_at
  }

  TASKS {
    text id PK
    text room_id FK
    text title
    text status
    text assignee_id
    integer created_at
  }

  CHECKINS {
    text id PK
    text user_id FK
    text room_id FK
    int  mood
    int  energy
    text status
    integer created_at
  }

  DEVICES {
    text id PK
    text room_id FK
    text name
    text kind
    text secret
    integer created_at
  }

  READINGS {
    text id PK
    text device_id FK
    float t_c
    float noise_db
    float lux
    integer created_at
  }

  SUGGESTIONS {
    text id PK
    text room_id FK
    text user_id
    text kind
    text text
    integer created_at
  }

  USERS ||--o{ ROOM_MEMBERS : joins
  ROOMS ||--o{ ROOM_MEMBERS : has
  USERS ||--o{ MESSAGES : writes
  ROOMS ||--o{ MESSAGES : contains
  ROOMS ||--o{ TASKS : has
  USERS ||--o{ TASKS : assigned_to
  USERS ||--o{ CHECKINS : makes
  ROOMS ||--o{ CHECKINS : in
  ROOMS ||--o{ DEVICES : has
  DEVICES ||--o{ READINGS : produce
  ROOMS ||--o{ SUGGESTIONS : for
  USERS ||--o{ SUGGESTIONS : target_optional
````

## File: docs/mermaid/flow.mmd
````
%% fluxo principal — navegação do usuário
sequenceDiagram
  autonumber
  participant C as client (pwa)
  participant API as worker /api
  participant DB as d1
  participant KV as kv

  C->>API: POST /auth/login {email, pass}
  API->>DB: verify user + argon2id(pass)
  DB-->>API: user ok
  API->>KV: set session (jwt) + rate key
  API-->>C: 200 {jwt}

  C->>API: GET /rooms
  API->>DB: select rooms
  API-->>C: rooms list

  C->>API: GET /rooms/:id/messages?cursor=...
  API->>DB: page messages
  API-->>C: messages page

  C->>API: POST /rooms/:id/checkins {mood,energy,status}
  API->>DB: insert checkin
  API-->>C: 204

  C->>API: GET /rooms/:id/suggestions
  API->>DB: fetch latest readings + checkins
  API->>KV: read agent-cache (optional)
  API-->>C: [{kind,text}]
````

## File: docs/mermaid/iot.mmd
````
%% ingestão iot — validação + persistência
sequenceDiagram
  autonumber
  participant DEV as iot_sim
  participant API as worker /api/iot/ingest
  participant DB as d1

  DEV->>API: POST /iot/ingest {device_id,t_c,noise_db,lux,ts}\nHeader: X-Device-Secret
  API->>DB: select devices.id,secret where id=device_id
  DB-->>API: secret
  API->>API: compare secrets + rate check
  API->>DB: insert readings(...)
  API-->>DEV: 202 accepted
````

## File: docs/mermaid/states.mmd
````
%% estados de presença — client
stateDiagram-v2
  [*] --> afk
  afk --> solo: activity detected
  solo --> focus: toggle focus
  focus --> pair: invite/accept
  pair --> solo: end session
  any --> afk: idle timeout
````

## File: docs/e2e.sh
````bash
set -euo pipefail
BASE_URL=${BASE_URL:-"http://127.0.0.1:8787"}
EVIDENCES_FILE=${EVIDENCES_FILE:-"./docs/evidencias.txt"}
EMAIL="e2e-$(date +%s)@holo.work"
PASSWORD="devpass"
ROOM="room-holo"
log() {
  echo "[$(date '+%H:%M:%S')] $*" | tee -a "$EVIDENCES_FILE"
}
rm -f "$EVIDENCES_FILE"
log "# BASE_URL=$BASE_URL"
log "# register"
curl -sS "$BASE_URL/api/auth/register" \
  -H 'content-type: application/json' \
  -d "{\"email\":\"$EMAIL\",\"password\":\"$PASSWORD\"}" | tee -a "$EVIDENCES_FILE"
JWT=$(curl -sS "$BASE_URL/api/auth/login" \
  -H 'content-type: application/json' \
  -d "{\"email\":\"$EMAIL\",\"password\":\"$PASSWORD\"}" | tee -a "$EVIDENCES_FILE" | jq -r .jwt)
log "# join room"
curl -sS "$BASE_URL/api/rooms/$ROOM/join" -H "authorization: Bearer $JWT" -X POST | tee -a "$EVIDENCES_FILE"
log "# post message"
curl -sS "$BASE_URL/api/rooms/$ROOM/messages" \
  -H "authorization: Bearer $JWT" \
  -H 'content-type: application/json' \
  -d '{"body":"hello from e2e"}' | tee -a "$EVIDENCES_FILE"
log "# ingest sample"
curl -sS "$BASE_URL/api/iot/ingest" \
  -H 'content-type: application/json' \
  -H 'X-Device-Secret: DEVSECRET123' \
  -d '{"device_id":"device-holo-01","t_c":25,"noise_db":55,"lux":300}' | tee -a "$EVIDENCES_FILE"
log "# fetch suggestions"
curl -sS "$BASE_URL/api/rooms/$ROOM/suggestions" -H "authorization: Bearer $JWT" | tee -a "$EVIDENCES_FILE"
````

## File: docs/ENV.md
````markdown
# Environment Checklist

## Required
- `JWT_SECRET`: 32+ char random string.
- `PEPPER`: short random string (dev: `dev-pepper` so seed admin hash matches).

## Optional
- `ZAI_API_KEY`: reserved for future asset generation.

## Local Dev
- Create `worker/.dev.vars`:
  ```
  JWT_SECRET=dev-jwt-secret-please-change
  PEPPER=dev-pepper
  ```
- Run `npm run dev` (Miniflare loads `.dev.vars`).

## Prod
- Use `wrangler secret put ... --config worker/wrangler.toml` per `docs/DEPLOY.md`.
````

## File: docs/FIAP_PACKAGE.md
````markdown
# FIAP Package Checklist

1. **Zip**
   ```bash
   zip -r dist/holo-work-fiap.zip worker ui sql scripts docs README.md LICENSE package.json package-lock.json
   ```
2. **PDF mapping**
   - Export PRD → FIAP requirements mapping (use docs/PRD.md sections). Tools: Google Docs or pandoc.
3. **TXT (RM + nome + link do pitch)**
   ```
   RM123456
   Daniel Alexandre Barcellos de Brito
   https://youtu.be/<pitch>
   ```
4. **Pitch video**
   - 3 min walkthrough (follow `docs/pitch-script.md`).
5. **Contents inside zip**
   - Source code
   - Docs (PRD, DEPLOY, ENV, pitch script, evidence)
   - PDF mapping
   - TXT with RM/Name/Pitch
````

## File: docs/pitch-script.md
````markdown
# Pitch Script (3 min)

- **0:00–0:30 Problema**: trabalho híbrido fragmenta sinais, falta visibilidade de conforto, pairing e ritmo.
- **0:30–1:30 Demo**: login → room map/presença → chat/tasks → check-in slider → IoT readings → agente sugere pausa/mudança.
- **1:30–2:15 Arquitetura**: CF Worker + D1 + KV; IoT ingest; agent heuristics; static UI; simulator; deploy pipeline.
- **2:15–2:45 Impacto/ODS**: ODS 4/8/9/10, bem-estar, inclusão híbrida.
- **2:45–3:00 CTA**: convite para piloto + próximos passos (AI assets, FIAP requirements).
````

## File: docs/PRD.md
````markdown
# prd.md — holo.work (v1)

## visão

um espaço de trabalho híbrido leve (2d/pixel), com presença, chat e quadros de tarefas, que integra leituras iot (simuladas) e um agente de recomendação para ritmo saudável e pairing. web/mobile responsivo, cloudflare-first, dados em d1, eventos em kv. sem framework pesado.

## problema

trabalho distribuído fragmenta sinal: status, foco, conforto, saúde. reuniões viram ruído. precisamos de um hub que enxergue contexto e sugira ações práticas sem fricção.

## objetivos

* reduzir atrito de colaboração remota.
* dar visibilidade de conforto/ambiente via iot simulado.
* promover pausas e pairing guiados por dados.
* mvp executável em 1 click com wrangler.

## escopo (v1)

* espaços (rooms) com mapa 2d leve (tiles/png), presença, chat, tasks.
* check-in de humor/energia (1..5) e status (focus, solo, pair, afk).
* ingest de iot: temperatura, ruído, luminosidade (mock) por device.
* agente: recomenda pausas, pairing e sala mais “confortável”.
* auth: e-mail + senha com hash; roles: admin, user.
* admin web local (sem login externo) para CRUD rápido de rooms/devices.

fora do escopo v1: voz, video, 3d, calendário integrado, oauth.

## personas

* dev/design: quer foco, pairing rápido, status claro.
* gestor: quer visibilidade de conforto e carga do time.
* ops: quer quedas/alertas simples de ambiente.

## fluxos principais

1. login -> escolher room -> ver mapa/presenças -> chat/tasks -> check-in -> agente sugere ação.
2. admin local gera room, device e seeds de mapa.
3. iot_sim envia POST periódico em /api/iot/ingest.

## arquitetura

* ui: html+css+js (es modules), render 2d canvas/pixel; pwa básico.
* api: cloudflare worker (ts) com rotas rest, jwt, rate-limit kv.
* dados: d1 (sqlite). kv: sessions, rate, agent-cache, stream buffers.
* iot: script python envia leituras; worker valida device_secret.
* agente: função no worker que lê leituras+checkins e gera recomendações simples (regras + score).

```
[ui] <-> [/api/* worker] <-> [d1]
                      \-> [kv]
[iot_sim] -> [/api/iot/ingest]
```

## modelo de dados (mínimo)

* users(id, email, pass_hash, role, created_at)
* rooms(id, name, slug, map_seed, created_at)
* room_members(user_id, room_id, joined_at)
* messages(id, room_id, user_id, body, created_at)
* tasks(id, room_id, title, status, assignee_id, created_at)
* checkins(id, user_id, room_id, mood, energy, status, created_at)
* devices(id, room_id, name, kind, secret, created_at)
* readings(id, device_id, t_c, noise_db, lux, created_at)
* suggestions(id, room_id, user_id, kind, text, created_at)

## sql (d1/sqlite)

```sql
create table users (
  id text primary key,
  email text unique not null,
  pass_hash text not null,
  role text not null default 'user',
  created_at integer not null
);
create table rooms (
  id text primary key,
  name text not null,
  slug text unique not null,
  map_seed text,
  created_at integer not null
);
create table room_members (
  user_id text not null,
  room_id text not null,
  joined_at integer not null,
  primary key(user_id, room_id)
);
create table messages (
  id text primary key,
  room_id text not null,
  user_id text not null,
  body text not null,
  created_at integer not null
);
create table tasks (
  id text primary key,
  room_id text not null,
  title text not null,
  status text not null default 'todo',
  assignee_id text,
  created_at integer not null
);
create table checkins (
  id text primary key,
  user_id text not null,
  room_id text not null,
  mood integer,
  energy integer,
  status text, -- focus|solo|pair|afk
  created_at integer not null
);
create table devices (
  id text primary key,
  room_id text not null,
  name text not null,
  kind text not null, -- env
  secret text not null,
  created_at integer not null
);
create table readings (
  id text primary key,
  device_id text not null,
  t_c real,
  noise_db real,
  lux real,
  created_at integer not null
);
create table suggestions (
  id text primary key,
  room_id text not null,
  user_id text,
  kind text not null, -- pause|pair|move
  text text not null,
  created_at integer not null
);
```

## api (rest)

* auth

  * POST /api/auth/register {email, password}
  * POST /api/auth/login {email, password} -> {jwt}
  * GET  /api/auth/me -> user
* rooms

  * GET /api/rooms
  * POST /api/rooms (admin)
  * GET /api/rooms/:id
  * POST /api/rooms/:id/join
* messages

  * GET /api/rooms/:id/messages?cursor=...
  * POST /api/rooms/:id/messages {body}
* tasks

  * GET/POST /api/rooms/:id/tasks
  * PUT /api/tasks/:id {status, assignee_id}
* checkins

  * POST /api/rooms/:id/checkins {mood, energy, status}
  * GET  /api/rooms/:id/checkins?since=ts
* devices/iot

  * POST /api/devices (admin) -> {id, secret}
  * POST /api/iot/ingest {device_id, t_c, noise_db, lux, ts} header: X-Device-Secret
  * GET  /api/rooms/:id/readings?window=15m
* agente

  * GET /api/rooms/:id/suggestions

jwt no header Authorization. rate-limit por ip em kv. argon2id para hash.

## agente (heurística v1)

* se noise_db>65 e energy<3 -> move para sala X com menor ruído.
* se t_c>27 e mood<=2 -> pausa 5min + água.
* se 2 usuários com status focus>30min no mesmo room e tasks relacionadas -> sugerir pairing.
* se lux<200 -> ajustar iluminação (nota).

## segurança

* hash: argon2id; pepper em secret.
* jwt curto (15min) + refresh opcional em cookie httpOnly (v1 opcional).
* validação de input, limitar body 32KB, sane de html no chat.
* secrets: wrangler secret. no repo só nomes.

## nfr

* p50 api < 100ms; p95 < 300ms.
* primeiro byte ui < 200ms via pages.
* ingest suporta 10 req/s no free.

## telemetria

* counters no kv: logins, msgs, tasks_move, sugestões aceitas.

## critérios de sucesso

* demo com 2 rooms, 3 usuários, iot_sim rodando.
* sugestões aparecem reagindo a leituras e checkins.
* zip+pdf+pitch de 3min.

## env vars

* JWT_SECRET
* PEPPER
* DEVICE_INGEST_RATE_MAX (opcional)
* ZAI_API_KEY (geração de assets opcional)

## fiap mapping

1. banco: sql acima (>=4 entidades).
2. api: rotas rest (>=5 endpoints).
3. testes: plano e 3 execuções (unit simples + curl evidências).
4. mobile: pwa responsivo 3 telas (login, room, tasks).
5. segurança: hash, roles, validação, rate-limit.
6. iot: iot_sim + ingest + uso em sugestões e painel.

---
````

## File: docs/todo.md
````markdown
# Execução v1 Checklist

## 0. Repo hygiene
- [x] Create repo `holo.work` with `/worker`, `/ui`, `/sql`, `/scripts`, `/docs` scaffolding.
- [x] Add MIT `LICENSE`, succinct `README`, project `.gitignore`, and `.editorconfig` with LF/ts defaults.

## 1. Infra
- [x] Author `wrangler.toml` (main entry, compatibility date, bindings for DB/KV) per AGENTS spec.
- [x] Run `wrangler d1 create holo_work` and `wrangler kv namespace create KV`, capture IDs into config.

## 2. Database
- [x] Apply `/sql/schema.sql` via `wrangler d1 execute`.
- [x] Create `/sql/seed.sql` with admin user (`admin@holo.work` / "admin" dev pw), two rooms, one device + shared secret.

## 3. Auth
- [ ] Implement Argon2id hash/verify with `PEPPER` (currently using PBKDF2-SHA256 as a temporary fallback while we wire deterministic WASM support), short helper tests.
- [x] Implement JWT issue/verify (15 min TTL) + middleware.
- [x] Ship `/auth/register`, `/auth/login`, `/auth/me` routes with validation + rate-limit hooks.

## 4. Rooms/Core
- [x] CRUD for rooms (admin create, anyone list/join) with ownership guard.
- [x] Chat: GET last N messages + POST with html-escape + basic flood control.
- [x] Tasks: GET/POST/PUT with assignee + status tracking.
- [x] Check-ins: POST mood/energy/status slider payload + GET last 30 min per room.

## 5. IoT
- [x] Admin POST to issue device id + secret (persist hashed secret) and list existing devices.
- [x] `/iot/ingest` POST verifying `X-Device-Secret`, storing readings (temp/noise/lux) keyed by room, limited to 15 min retention.
- [x] `/rooms/:id/readings` GET returning sliding-window telemetry.

## 6. Agent
- [x] Implement `computeSuggestions(room_id)` per spec (15 min readings + 30 min check-ins, dedupe within 10 min window, idempotent insert).
- [x] Expose suggestions GET route and ensure ingest/check-in paths trigger compute when new data arrives.

## 7. UI
- [x] `index.html`: login form → fetch auth → store JWT in memory + `sessionStorage`.
- [x] `room.html`: 16x16 grid map + presence dots, tabs para chat/tasks/ambiente/sugestões, check-in slider + status select.
- [x] `admin.html`: `?local=1` guard, forms p/ criar rooms/devices + lista de secrets (local only).
- [x] Shared ES modules (API client/state) + CSS utilitário leve (sem frameworks).

## 8. Scripts
- [x] `scripts/iot_sim.py` using stdlib `urllib` to read `INGEST_URL`, `DEVICE_ID`, `DEVICE_SECRET`, and send payload every 5 s (temp 20-32 °C etc.).

## 9. Security
- [x] Central JSON validator + body size cap, sanitize chat HTML, enforce 60 rpm/IP via KV counter.
- [x] Ensure secrets never logged; use environment vars `JWT_SECRET`, `PEPPER`, optional `ZAI_API_KEY` stub (ver README + `docs/ENV.md`, `.dev.vars` para dev).

## 10. Tests & Evidence
- [x] Unit tests for hash/verify and `computeSuggestions` helpers.
- [x] `./docs/e2e.sh` curl flow: register → login → create room → post message → ingest → read suggestions; script grava em `./docs/evidencias.txt`.

## 11. Deploy
- [x] `wrangler publish` playbook em `docs/DEPLOY.md` (bindings, secrets, schema, smoke). `wrangler dev` validado local.
- [x] Serve `/ui` via Pages ou worker assets (detalhado em README/DEPLOY).

## 12. Fiap package
- [x] Checklist em `docs/FIAP_PACKAGE.md` (zip, PDF mapping, TXT com RM/nome/pitch-link).

## 13. Pitch script
- [x] Roteiro (`docs/pitch-script.md`) cobre problema/demo/arquitetura/ODS/CTA.

## 14. Env checklist
- [x] `docs/ENV.md` + README explicam secrets (`JWT_SECRET`, `PEPPER`, `ZAI_API_KEY` opcional) e uso de `.dev.vars`.

## 15. Definition of Done
- [x] Local demo + IoT sim verificados; docs de deploy/tests/pacote asseguram handoff cloud + zip.
````

## File: scripts/iot_sim.py
````python
from __future__ import annotations
import json
import os
import random
import time
import urllib.error
import urllib.request
INGEST_URL = os.getenv("INGEST_URL")
DEVICE_ID = os.getenv("DEVICE_ID")
DEVICE_SECRET = os.getenv("DEVICE_SECRET")
if not INGEST_URL or not DEVICE_ID or not DEVICE_SECRET:
  raise SystemExit("Set INGEST_URL, DEVICE_ID and DEVICE_SECRET env vars")
HEADERS = {
  "Content-Type": "application/json",
  "X-Device-Secret": DEVICE_SECRET,
}
print(f"→ streaming telemetry to {INGEST_URL} for {DEVICE_ID}")
while True:
  payload = {
    "device_id": DEVICE_ID,
    "t_c": round(random.uniform(20.0, 32.0), 2),
    "noise_db": round(random.uniform(40.0, 75.0), 1),
    "lux": round(random.uniform(60.0, 600.0), 0),
    "ts": int(time.time() * 1000),
  }
  data = json.dumps(payload).encode("utf-8")
  req = urllib.request.Request(INGEST_URL, data=data, headers=HEADERS, method="POST")
  try:
    with urllib.request.urlopen(req, timeout=10) as resp:
      if resp.status != 200:
        print(f"! ingest failed status={resp.status}")
      else:
        print(f"✓ sent {payload}")
  except urllib.error.HTTPError as exc:
    print(f"HTTP {exc.code}: {exc.read().decode('utf-8', 'ignore')}")
  except urllib.error.URLError as exc:
    print(f"Request failed: {exc}")
  time.sleep(5)
````

## File: sql/schema.sql
````sql
PRAGMA foreign_keys = ON;
CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  pass_hash TEXT NOT NULL,
  role TEXT NOT NULL DEFAULT 'user',
  created_at INTEGER NOT NULL
);
CREATE TABLE IF NOT EXISTS rooms (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  slug TEXT NOT NULL UNIQUE,
  map_seed TEXT,
  created_at INTEGER NOT NULL
);
CREATE TABLE IF NOT EXISTS room_members (
  user_id TEXT NOT NULL,
  room_id TEXT NOT NULL,
  joined_at INTEGER NOT NULL,
  PRIMARY KEY (user_id, room_id),
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (room_id) REFERENCES rooms(id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS messages (
  id TEXT PRIMARY KEY,
  room_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  body TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  FOREIGN KEY (room_id) REFERENCES rooms(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
CREATE INDEX IF NOT EXISTS idx_messages_room_created ON messages(room_id, created_at DESC);
CREATE TABLE IF NOT EXISTS tasks (
  id TEXT PRIMARY KEY,
  room_id TEXT NOT NULL,
  title TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'todo',
  assignee_id TEXT,
  created_at INTEGER NOT NULL,
  FOREIGN KEY (room_id) REFERENCES rooms(id) ON DELETE CASCADE,
  FOREIGN KEY (assignee_id) REFERENCES users(id) ON DELETE SET NULL
);
CREATE INDEX IF NOT EXISTS idx_tasks_room_created ON tasks(room_id, created_at DESC);
CREATE TABLE IF NOT EXISTS checkins (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  room_id TEXT NOT NULL,
  mood INTEGER,
  energy INTEGER,
  status TEXT,
  created_at INTEGER NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (room_id) REFERENCES rooms(id) ON DELETE CASCADE
);
CREATE INDEX IF NOT EXISTS idx_checkins_room_created ON checkins(room_id, created_at DESC);
CREATE TABLE IF NOT EXISTS devices (
  id TEXT PRIMARY KEY,
  room_id TEXT NOT NULL,
  name TEXT NOT NULL,
  kind TEXT NOT NULL,
  secret_hash TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  FOREIGN KEY (room_id) REFERENCES rooms(id) ON DELETE CASCADE
);
CREATE INDEX IF NOT EXISTS idx_devices_room ON devices(room_id);
CREATE TABLE IF NOT EXISTS readings (
  id TEXT PRIMARY KEY,
  device_id TEXT NOT NULL,
  room_id TEXT NOT NULL,
  t_c REAL,
  noise_db REAL,
  lux REAL,
  created_at INTEGER NOT NULL,
  FOREIGN KEY (device_id) REFERENCES devices(id) ON DELETE CASCADE,
  FOREIGN KEY (room_id) REFERENCES rooms(id) ON DELETE CASCADE
);
CREATE INDEX IF NOT EXISTS idx_readings_room_created ON readings(room_id, created_at DESC);
CREATE TABLE IF NOT EXISTS suggestions (
  id TEXT PRIMARY KEY,
  room_id TEXT NOT NULL,
  user_id TEXT,
  kind TEXT NOT NULL,
  text TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  UNIQUE(room_id, kind, text, created_at),
  FOREIGN KEY (room_id) REFERENCES rooms(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
);
CREATE INDEX IF NOT EXISTS idx_suggestions_room_created ON suggestions(room_id, created_at DESC);
CREATE TABLE IF NOT EXISTS events (
  id TEXT PRIMARY KEY,
  room_id TEXT,
  kind TEXT NOT NULL,
  payload TEXT,
  created_at INTEGER NOT NULL
);
````

## File: ui/css/style.css
````css
:root {
  font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
  color: #101828;
  background: #f5f5f7;
  --card-bg: #ffffff;
  --accent: #6366f1;
  --muted: #475467;
  --border: #e4e7ec;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  min-height: 100vh;
  background: radial-gradient(circle at top, #eef2ff 0%, #f8fafc 55%, #ffffff 100%);
}
a {
  color: var(--accent);
}
main {
  max-width: 1200px;
  margin: 0 auto;
  padding: 2rem;
}
.card {
  background: var(--card-bg);
  border-radius: 16px;
  border: 1px solid var(--border);
  box-shadow: 0 20px 45px rgba(15, 23, 42, 0.08);
  padding: 2rem;
}
button, input, select, textarea {
  font: inherit;
  padding: 0.65rem 0.85rem;
  border-radius: 10px;
  border: 1px solid var(--border);
}
button {
  background: var(--accent);
  color: #fff;
  border: none;
  cursor: pointer;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}
button:hover {
  transform: translateY(-1px);
  box-shadow: 0 8px 20px rgba(99, 102, 241, 0.3);
}
.login-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
  gap: 2rem;
}
.input-group {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
}
.tabs button {
  flex: 1;
  background: #f4f4ff;
  color: var(--muted);
  border: 1px solid transparent;
}
.tabs button.active {
  background: var(--accent);
  color: #fff;
}
.panel {
  display: none;
}
.panel.active {
  display: block;
}
.room-layout {
  display: grid;
  grid-template-columns: 420px 1fr;
  gap: 1.5rem;
}
.map-card {
  background: var(--card-bg);
  border-radius: 16px;
  border: 1px solid var(--border);
  padding: 1rem;
  min-height: 500px;
}
#roomGrid {
  width: 100%;
  aspect-ratio: 1 / 1;
  border: 1px dashed var(--border);
  border-radius: 12px;
  background: repeating-linear-gradient(90deg, rgba(99, 102, 241, 0.08) 0, rgba(99, 102, 241, 0.08) 1px, transparent 1px, transparent calc(100% / 16)),
    repeating-linear-gradient(0deg, rgba(99, 102, 241, 0.08) 0, rgba(99, 102, 241, 0.08) 1px, transparent 1px, transparent calc(100% / 16));
}
.presence-list {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin-top: 1rem;
}
.presence-dot {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background: rgba(99, 102, 241, 0.15);
  color: var(--accent);
  font-weight: 600;
}
.chat-list,
.task-list,
.suggestion-list,
.metric-list {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  max-height: 320px;
  overflow-y: auto;
}
.message {
  padding: 0.75rem;
  border: 1px solid var(--border);
  border-radius: 12px;
}
.metric-card {
  display: flex;
  justify-content: space-between;
  padding: 0.75rem 1rem;
  border: 1px solid var(--border);
  border-radius: 12px;
  background: rgba(99, 102, 241, 0.05);
}
.admin-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
  gap: 1.5rem;
}
.notice {
  padding: 1rem;
  border-radius: 12px;
  border: 1px solid #fee4bc;
  background: #fff7ed;
  color: #9a3412;
}
````

## File: ui/js/admin.js
````javascript
import { apiFetch, ensureAuth } from './api.js';
const allowed = new URLSearchParams(window.location.search).get('local') === '1';
const gateNotice = document.querySelector('#gateNotice');
const roomForm = document.querySelector('#roomAdminForm');
const deviceForm = document.querySelector('#deviceForm');
const deviceList = document.querySelector('#deviceList');
const deviceRoomSelect = document.querySelector('#deviceRoom');
const secretBox = document.querySelector('#secretBox');
const backBtn = document.querySelector('#backBtn');
ensureAuth();
if (!allowed) {
  gateNotice.textContent = 'Liberado apenas com ?local=1';
  roomForm.querySelectorAll('input,button,select').forEach((el) => (el.disabled = true));
  deviceForm.querySelectorAll('input,button,select').forEach((el) => (el.disabled = true));
} else {
  gateNotice.textContent = 'Somente uso local. Não exponha secrets em prod.';
  loadRooms();
  loadDevices();
}
roomForm.addEventListener('submit', async (event) => {
  event.preventDefault();
  if (!allowed) return;
  const formData = new FormData(roomForm);
  await apiFetch('/api/rooms', {
    method: 'POST',
    body: JSON.stringify({
      name: formData.get('name'),
      map_seed: formData.get('map_seed'),
    }),
  });
  roomForm.reset();
  loadRooms();
});
deviceForm.addEventListener('submit', async (event) => {
  event.preventDefault();
  if (!allowed) return;
  const formData = new FormData(deviceForm);
  const payload = {
    room_id: formData.get('room_id'),
    name: formData.get('name'),
  };
  const result = await apiFetch('/api/devices', { method: 'POST', body: JSON.stringify(payload) });
  secretBox.textContent = `ID: ${result.device.id} • SECRET: ${result.secret}`;
  deviceForm.reset();
  loadDevices();
});
backBtn.addEventListener('click', () => {
  window.location.href = 'room.html';
});
async function loadRooms() {
  const data = await apiFetch('/api/rooms');
  deviceRoomSelect.innerHTML = data.rooms.map((room) => `<option value="${room.id}">${room.name}</option>`).join('');
}
async function loadDevices() {
  if (!allowed) return;
  const data = await apiFetch('/api/devices');
  if (!data.devices.length) {
    deviceList.innerHTML = '<p>Nenhum device.</p>';
    return;
  }
  deviceList.innerHTML = data.devices
    .map(
      (dev) => `
        <div class="message">
          <strong>${dev.name}</strong>
          <p style="margin:0.25rem 0;">${dev.id} → sala ${dev.room_id}</p>
          <small>${new Date(dev.created_at).toLocaleString()}</small>
        </div>`
    )
    .join('');
}
````

## File: ui/js/api.js
````javascript
const TOKEN_KEY = 'holo_jwt';
let memoryToken = null;
const DEFAULT_API_BASE =
  window.__HOLO_API__ ||
  (location.port === '4173' || location.port === '4174' ? 'http://127.0.0.1:8787' : '');
export function getToken() {
  if (memoryToken) return memoryToken;
  memoryToken = sessionStorage.getItem(TOKEN_KEY);
  return memoryToken;
}
export function setToken(token) {
  memoryToken = token;
  if (token) {
    sessionStorage.setItem(TOKEN_KEY, token);
  } else {
    sessionStorage.removeItem(TOKEN_KEY);
  }
}
export function ensureAuth() {
  if (!getToken()) {
    window.location.href = 'index.html';
  }
}
export async function apiFetch(path, options = {}) {
  const headers = new Headers(options.headers || {});
  const token = getToken();
  if (token) {
    headers.set('authorization', `Bearer ${token}`);
  }
  if (options.body && !headers.has('content-type')) {
    headers.set('content-type', 'application/json');
  }
  const url = buildUrl(path);
  const response = await fetch(url, { ...options, headers });
  if (response.status === 401) {
    setToken(null);
    window.location.href = 'index.html';
    return null;
  }
  if (!response.ok) {
    let details;
    try {
      details = await response.json();
    } catch (err) {
      details = { error: response.statusText };
    }
    throw new Error(details.error || 'Request failed');
  }
  if (response.status === 204) return null;
  return response.json();
}
function buildUrl(path) {
  if (path.startsWith('http')) return path;
  if (!DEFAULT_API_BASE) return path;
  if (path.startsWith('/')) {
    return `${DEFAULT_API_BASE}${path}`;
  }
  return `${DEFAULT_API_BASE}/${path}`;
}
export function formToJSON(form) {
  const data = new FormData(form);
  return Object.fromEntries(data.entries());
}
````

## File: ui/js/index.js
````javascript
import { apiFetch, setToken } from './api.js';
const loginForm = document.querySelector('#loginForm');
const registerBtn = document.querySelector('#registerBtn');
const statusBox = document.querySelector('#status');
loginForm.addEventListener('submit', async (event) => {
  event.preventDefault();
  const formData = new FormData(loginForm);
  const payload = {
    email: formData.get('email'),
    password: formData.get('password'),
  };
  await authRequest('/api/auth/login', payload);
});
registerBtn.addEventListener('click', async () => {
  const formData = new FormData(loginForm);
  const payload = {
    email: formData.get('email'),
    password: formData.get('password'),
  };
  await authRequest('/api/auth/register', payload);
});
async function authRequest(path, payload) {
  try {
    statusBox.textContent = 'Enviando...';
    const result = await apiFetch(path, { method: 'POST', body: JSON.stringify(payload) });
    setToken(result.jwt);
    statusBox.textContent = 'Pronto! Redirecionando...';
    window.location.href = 'room.html';
  } catch (err) {
    statusBox.textContent = err.message;
  }
}
````

## File: ui/js/room.js
````javascript
import { apiFetch, ensureAuth, setToken } from './api.js';
const state = {
  rooms: [],
  roomId: null,
  pollHandle: null,
};
const ui = {
  roomSelect: document.querySelector('#roomSelect'),
  checkinForm: document.querySelector('#checkinForm'),
  roomStatus: document.querySelector('#roomStatus'),
  chatList: document.querySelector('#chatList'),
  messageForm: document.querySelector('#messageForm'),
  messageInput: document.querySelector('#messageBody'),
  tasksList: document.querySelector('#tasksList'),
  taskForm: document.querySelector('#taskForm'),
  metricList: document.querySelector('#metricList'),
  suggestionList: document.querySelector('#suggestionList'),
  presenceList: document.querySelector('#presenceList'),
  mapCanvas: document.querySelector('#roomGrid'),
  logoutBtn: document.querySelector('#logoutBtn'),
};
ensureAuth();
setupTabs();
attachEvents();
loadRooms();
function attachEvents() {
  ui.roomSelect.addEventListener('change', (event) => setRoom(event.target.value));
  ui.messageForm.addEventListener('submit', handleSendMessage);
  ui.taskForm.addEventListener('submit', handleCreateTask);
  ui.tasksList.addEventListener('click', handleTaskAction);
  ui.checkinForm.addEventListener('submit', handleCheckin);
  ui.logoutBtn.addEventListener('click', () => {
    setToken(null);
    window.location.href = 'index.html';
  });
}
async function loadRooms() {
  try {
    const data = await apiFetch('/api/rooms');
    state.rooms = data.rooms || [];
    ui.roomSelect.innerHTML = state.rooms.map((room) => `<option value="${room.id}">${room.name}</option>`).join('');
    const queryRoom = new URLSearchParams(window.location.search).get('room');
    const initial = queryRoom && state.rooms.find((r) => r.id === queryRoom) ? queryRoom : state.rooms[0]?.id;
    if (initial) {
      ui.roomSelect.value = initial;
      await setRoom(initial);
    }
  } catch (err) {
    ui.roomStatus.textContent = err.message;
  }
}
async function setRoom(roomId) {
  if (!roomId) return;
  state.roomId = roomId;
  await apiFetch(`/api/rooms/${roomId}/join`, { method: 'POST' });
  await refreshRoom();
  if (state.pollHandle) clearInterval(state.pollHandle);
  state.pollHandle = setInterval(refreshRoom, 8000);
}
async function refreshRoom() {
  if (!state.roomId) return;
  ui.roomStatus.textContent = 'Atualizando...';
  try {
    const [messages, tasks, readings, suggestions, checkins] = await Promise.all([
      apiFetch(`/api/rooms/${state.roomId}/messages?limit=50`),
      apiFetch(`/api/rooms/${state.roomId}/tasks`),
      apiFetch(`/api/rooms/${state.roomId}/readings?window=15`),
      apiFetch(`/api/rooms/${state.roomId}/suggestions`),
      apiFetch(`/api/rooms/${state.roomId}/checkins`),
    ]);
    renderMessages(messages?.messages || []);
    renderTasks(tasks?.tasks || []);
    renderMetrics(readings?.summary, readings?.readings || []);
    renderSuggestions(suggestions?.suggestions || []);
    renderPresence(checkins?.checkins || []);
    ui.roomStatus.textContent = `Atualizado às ${new Date().toLocaleTimeString()}`;
  } catch (err) {
    ui.roomStatus.textContent = err.message;
  }
}
async function handleSendMessage(event) {
  event.preventDefault();
  if (!state.roomId) return;
  const body = ui.messageInput.value.trim();
  if (!body) return;
  await apiFetch(`/api/rooms/${state.roomId}/messages`, {
    method: 'POST',
    body: JSON.stringify({ body }),
  });
  ui.messageInput.value = '';
  refreshRoom();
}
async function handleCreateTask(event) {
  event.preventDefault();
  if (!state.roomId) return;
  const formData = new FormData(ui.taskForm);
  await apiFetch(`/api/rooms/${state.roomId}/tasks`, {
    method: 'POST',
    body: JSON.stringify({ title: formData.get('title') }),
  });
  ui.taskForm.reset();
  refreshRoom();
}
function handleTaskAction(event) {
  const btn = event.target.closest('[data-task-id]');
  if (!btn) return;
  const id = btn.dataset.taskId;
  const current = btn.dataset.status;
  const next = current === 'todo' ? 'doing' : current === 'doing' ? 'done' : 'todo';
  apiFetch(`/api/tasks/${id}`, {
    method: 'PUT',
    body: JSON.stringify({ status: next }),
  }).then(refreshRoom);
}
async function handleCheckin(event) {
  event.preventDefault();
  if (!state.roomId) return;
  const formData = new FormData(ui.checkinForm);
  await apiFetch(`/api/rooms/${state.roomId}/checkins`, {
    method: 'POST',
    body: JSON.stringify({
      mood: Number(formData.get('mood')),
      energy: Number(formData.get('energy')),
      status: formData.get('status'),
    }),
  });
  refreshRoom();
}
function renderMessages(messages) {
  ui.chatList.innerHTML = messages
    .map(
      (msg) => `
        <div class="message">
          <strong>${msg.email || ''}</strong>
          <p>${msg.body}</p>
          <small>${new Date(msg.created_at).toLocaleTimeString()}</small>
        </div>`
    )
    .join('');
}
function renderTasks(tasks) {
  if (!tasks.length) {
    ui.tasksList.innerHTML = '<p>Nenhuma task por aqui.</p>';
    return;
  }
  ui.tasksList.innerHTML = tasks
    .map(
      (task) => `
        <div class="message">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div>
              <strong>${task.title}</strong>
              <p style="margin:0.25rem 0; color:var(--muted);">Status: ${task.status}</p>
            </div>
            <button data-task-id="${task.id}" data-status="${task.status}" style="min-width:90px;">${nextLabel(task.status)}</button>
          </div>
        </div>`
    )
    .join('');
}
function nextLabel(status) {
  if (status === 'todo') return 'Iniciar';
  if (status === 'doing') return 'Concluir';
  return 'Reabrir';
}
function renderMetrics(summary, readings) {
  if (!summary) {
    ui.metricList.innerHTML = '<p>Sem leituras recentes.</p>';
    return;
  }
  ui.metricList.innerHTML = `
    <div class="metric-card"><span>Temperatura média</span><strong>${summary.avg_t_c ?? '--'} °C</strong></div>
    <div class="metric-card"><span>Ruído médio</span><strong>${summary.avg_noise_db ?? '--'} dB</strong></div>
    <div class="metric-card"><span>Luz média</span><strong>${summary.avg_lux ?? '--'} lux</strong></div>
  `;
}
function renderSuggestions(list) {
  if (!list.length) {
    ui.suggestionList.innerHTML = '<p>Nenhuma sugestão ainda. Rode o simulador IoT.</p>';
    return;
  }
  ui.suggestionList.innerHTML = list
    .map(
      (item) => `
        <div class="message">
          <strong>${item.kind}</strong>
          <p>${item.text}</p>
          <small>${new Date(item.created_at).toLocaleTimeString()}</small>
        </div>`
    )
    .join('');
}
function renderPresence(checkins) {
  const latestByUser = new Map();
  checkins.forEach((entry) => {
    if (!latestByUser.has(entry.user_id)) {
      latestByUser.set(entry.user_id, entry);
    }
  });
  const presence = Array.from(latestByUser.values());
  ui.presenceList.innerHTML = presence
    .map((p) => `<div class="presence-dot" title="${p.email}">${initials(p.email)}</div>`)
    .join('');
  drawGrid(presence);
}
function initials(email) {
  return (email || '?').slice(0, 2).toUpperCase();
}
function drawGrid(presence) {
  const canvas = ui.mapCanvas;
  const size = canvas.clientWidth;
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, size, size);
  const cell = size / 16;
  ctx.fillStyle = '#eef2ff';
  ctx.fillRect(0, 0, size, size);
  ctx.strokeStyle = 'rgba(99,102,241,0.15)';
  for (let i = 0; i <= 16; i += 1) {
    ctx.beginPath();
    ctx.moveTo(i * cell, 0);
    ctx.lineTo(i * cell, size);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, i * cell);
    ctx.lineTo(size, i * cell);
    ctx.stroke();
  }
  presence.forEach((p) => {
    const seat = hashString(p.user_id);
    const col = seat % 16;
    const row = Math.floor(seat / 16) % 16;
    const x = col * cell + cell / 2;
    const y = row * cell + cell / 2;
    ctx.fillStyle = '#6366f1';
    ctx.beginPath();
    ctx.arc(x, y, cell * 0.35, 0, Math.PI * 2);
    ctx.fill();
  });
}
function hashString(input) {
  let hash = 0;
  for (let i = 0; i < input.length; i += 1) {
    hash = (hash * 31 + input.charCodeAt(i)) % 256;
  }
  return hash;
}
function setupTabs() {
  const buttons = document.querySelectorAll('.tabs button');
  buttons.forEach((btn) => {
    btn.addEventListener('click', () => {
      buttons.forEach((b) => b.classList.remove('active'));
      document.querySelectorAll('.panel').forEach((panel) => panel.classList.remove('active'));
      btn.classList.add('active');
      document.querySelector(`#${btn.dataset.tab}`).classList.add('active');
    });
  });
}
````

## File: ui/admin.html
````html
<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>holo.work — admin local</title>
    <link rel="stylesheet" href="./css/style.css" />
  </head>
  <body>
    <main>
      <section class="card" style="margin-bottom:1.5rem;">
        <h1>Admin local</h1>
        <p id="gateNotice">Carregando...</p>
        <button id="backBtn" style="background:#94a3b8;">Voltar</button>
      </section>
      <section class="admin-grid">
        <form id="roomAdminForm" class="card">
          <h3>Nova sala</h3>
          <div class="input-group">
            <label>Nome</label>
            <input type="text" name="name" placeholder="Focus Lab" required />
          </div>
          <div class="input-group">
            <label>Map seed</label>
            <input type="text" name="map_seed" placeholder="grid:16x16:lab" />
          </div>
          <button type="submit">Criar sala</button>
        </form>
        <form id="deviceForm" class="card">
          <h3>Emitir device</h3>
          <div class="input-group">
            <label>Sala</label>
            <select name="room_id" id="deviceRoom"></select>
          </div>
          <div class="input-group">
            <label>Nome</label>
            <input type="text" name="name" placeholder="Beacon 01" required />
          </div>
          <button type="submit">Gerar device</button>
          <p id="secretBox" style="margin-top:1rem; color:var(--accent);"></p>
        </form>
        <div class="card">
          <h3>Devices ativos</h3>
          <div id="deviceList" class="task-list"></div>
        </div>
      </section>
    </main>
    <script type="module" src="./js/admin.js"></script>
  </body>
</html>
````

## File: ui/index.html
````html
<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>holo.work — login</title>
    <link rel="stylesheet" href="./css/style.css" />
  </head>
  <body>
    <main>
      <section class="card">
        <h1>holo.work</h1>
        <p>Hub híbrido com presença, chat, tasks, IoT e agente que cuida do ritmo.</p>
        <div class="login-grid">
          <form id="loginForm">
            <div class="input-group">
              <label for="email">Email</label>
              <input id="email" name="email" type="email" placeholder="dev@holo.work" required />
            </div>
            <div class="input-group">
              <label for="password">Senha</label>
              <input id="password" name="password" type="password" placeholder="••••••" required />
            </div>
            <div style="display:flex; gap:0.75rem; margin-top:1rem;">
              <button type="submit" style="flex:1;">Entrar</button>
              <button type="button" id="registerBtn" style="flex:1; background:#0ea5e9;">Registrar</button>
            </div>
            <p class="notice" style="margin-top:1rem;">
              Use admin@holo.work / admin (PEPPER=dev-pepper) para seed local.
            </p>
          </form>
          <div>
            <h3>Como funciona?</h3>
            <p>
              1) Faz login → 2) Escolhe sala → 3) Marca presença, conversa e acompanha tarefas.
              O simulador IoT injeta temperatura, ruído e luz; o agente sugere pausas, pairing e ajustes.
            </p>
            <p>
              Depois de logar, compartilhe o token entre abas (sessionStorage). Para sair, limpe o token em
              <code>sessionStorage</code> ou clique em "sair" no header da sala.
            </p>
          </div>
        </div>
        <p id="status" style="margin-top:1rem; color:var(--accent);"></p>
      </section>
    </main>
    <script type="module" src="./js/index.js"></script>
  </body>
</html>
````

## File: ui/room.html
````html
<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>holo.work — sala</title>
    <link rel="stylesheet" href="./css/style.css" />
  </head>
  <body>
    <main>
      <section class="card" style="margin-bottom:1.5rem;">
        <header style="display:flex; gap:1rem; align-items:center;">
          <h2 style="flex:1;">Sala</h2>
          <select id="roomSelect" style="flex:2;"></select>
          <button id="logoutBtn" style="background:#f43f5e;">Sair</button>
        </header>
        <form id="checkinForm" style="display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:1rem; margin-top:1rem;">
          <div class="input-group">
            <label>Mood</label>
            <input type="range" min="1" max="5" step="1" name="mood" value="3" />
          </div>
          <div class="input-group">
            <label>Energia</label>
            <input type="range" min="1" max="5" step="1" name="energy" value="3" />
          </div>
          <div class="input-group">
            <label>Status</label>
            <select name="status">
              <option value="focus">Focus</option>
              <option value="solo">Solo</option>
              <option value="pair">Pair</option>
              <option value="afk">AFK</option>
            </select>
          </div>
          <button type="submit">Check-in</button>
        </form>
        <p id="roomStatus" style="margin-top:0.75rem; color:var(--muted);"></p>
      </section>
      <section class="room-layout">
        <div class="map-card">
          <canvas id="roomGrid"></canvas>
          <h4 style="margin-top:1rem;">Presenças recentes</h4>
          <div id="presenceList" class="presence-list"></div>
        </div>
        <div class="card">
          <div class="tabs">
            <button data-tab="chat" class="active">Chat</button>
            <button data-tab="tasks">Tasks</button>
            <button data-tab="ambiente">Ambiente</button>
            <button data-tab="sugestoes">Sugestões</button>
          </div>
          <div id="chat" class="panel active">
            <div id="chatList" class="chat-list"></div>
            <form id="messageForm" style="margin-top:1rem; display:flex; gap:0.5rem;">
              <input id="messageBody" type="text" placeholder="Compartilhe algo" required style="flex:1;" />
              <button type="submit">Enviar</button>
            </form>
          </div>
          <div id="tasks" class="panel">
            <div id="tasksList" class="task-list"></div>
            <form id="taskForm" style="margin-top:1rem; display:flex; gap:0.5rem;">
              <input name="title" type="text" placeholder="Nova task" required style="flex:1;" />
              <button type="submit">Adicionar</button>
            </form>
          </div>
          <div id="ambiente" class="panel">
            <div id="metricList" class="metric-list"></div>
          </div>
          <div id="sugestoes" class="panel">
            <div id="suggestionList" class="suggestion-list"></div>
          </div>
        </div>
      </section>
    </main>
    <script type="module" src="./js/room.js"></script>
  </body>
</html>
````

## File: worker/src/access.ts
````typescript
import { Env } from './types';
import { ensure } from './utils';
import { first } from './db';
export async function requireRoomMembership(env: Env, roomKey: string, userId: string): Promise<string> {
  const room = await first<{ id: string }>(env.DB, 'SELECT id FROM rooms WHERE id = ? OR slug = ?', [roomKey, roomKey]);
  ensure(room, 404, 'Room not found');
  const member = await first<{ user_id: string }>(
    env.DB,
    'SELECT user_id FROM room_members WHERE room_id = ? AND user_id = ?',
    [room!.id, userId]
  );
  ensure(member, 403, 'Join room first');
  return room!.id;
}
````

## File: worker/src/agent.ts
````typescript
import { HandlerContext, Env } from './types';
import { all, first, run } from './db';
import { jsonResponse, ensure, nowMs } from './utils';
import { requireRoomMembership } from './access';
const READING_WINDOW_MS = 15 * 60 * 1000;
const CHECKIN_WINDOW_MS = 30 * 60 * 1000;
const DEDUPE_WINDOW_MS = 10 * 60 * 1000;
interface ReadingRow {
  t_c: number | null;
  noise_db: number | null;
  lux: number | null;
  created_at: number;
}
interface CheckinRow {
  user_id: string;
  mood: number | null;
  energy: number | null;
  status: string | null;
  created_at: number;
}
export async function computeSuggestions(env: Env, roomId: string): Promise<void> {
  const now = nowMs();
  const readings = await all<ReadingRow>(
    env.DB,
    'SELECT t_c, noise_db, lux, created_at FROM readings WHERE room_id = ? AND created_at >= ? ORDER BY created_at DESC LIMIT 50',
    [roomId, now - READING_WINDOW_MS]
  );
  if (!readings.length) {
    return;
  }
  const checkins = await all<CheckinRow>(
    env.DB,
    'SELECT user_id, mood, energy, status, created_at FROM checkins WHERE room_id = ? AND created_at >= ? ORDER BY created_at DESC',
    [roomId, now - CHECKIN_WINDOW_MS]
  );
  const candidates = buildCandidates(readings, checkins);
  for (const suggestion of candidates) {
    const exists = await first<{ id: string }>(
      env.DB,
      'SELECT id FROM suggestions WHERE room_id = ? AND kind = ? AND created_at >= ? LIMIT 1',
      [roomId, suggestion.kind, now - DEDUPE_WINDOW_MS]
    );
    if (exists) continue;
    await run(
      env.DB,
      'INSERT INTO suggestions (id, room_id, user_id, kind, text, created_at) VALUES (?, ?, NULL, ?, ?, ?)',
      [crypto.randomUUID(), roomId, suggestion.kind, suggestion.text, now]
    );
  }
  await run(env.DB, 'DELETE FROM suggestions WHERE created_at < ?', [now - 6 * 60 * 60 * 1000]);
}
export function buildCandidates(readings: ReadingRow[], checkins: CheckinRow[]) {
  const latest = readings[0];
  const lowEnergy = checkins.filter((c) => typeof c.energy === 'number' && c.energy! <= 2);
  const lowMood = checkins.filter((c) => typeof c.mood === 'number' && c.mood! <= 2);
  const focusCount = checkins.filter((c) => c.status === 'focus').length;
  const candidates: Array<{ kind: string; text: string }> = [];
  if (typeof latest.noise_db === 'number' && latest.noise_db > 65 && lowEnergy.length) {
    candidates.push({
      kind: 'move',
      text: `Ruído elevado (~${latest.noise_db.toFixed(0)} dB). Liberar sala alternativa ou oferecer fones.`,
    });
  }
  if (typeof latest.t_c === 'number' && latest.t_c > 27 && lowMood.length) {
    candidates.push({
      kind: 'pause',
      text: `Temperatura em ${latest.t_c.toFixed(1)}°C com humor baixo. Propor pausa rápida + hidratação.`,
    });
  }
  if (typeof latest.lux === 'number' && latest.lux < 200) {
    candidates.push({
      kind: 'environment',
      text: `Luminosidade baixa (${latest.lux.toFixed(0)} lux). Ajustar luz ou mover para área mais iluminada.`,
    });
  }
  if (focusCount >= 2 && readings.length && (!lowMood.length || !lowEnergy.length)) {
    candidates.push({
      kind: 'pair',
      text: 'Há várias pessoas em foco por 30+ min. Sugerir pairing rápido para desbloquear tarefas críticas.',
    });
  }
  return candidates;
}
export async function handleGetSuggestions(ctx: HandlerContext): Promise<Response> {
  ensure(ctx.user, 401, 'Unauthorized');
  const { roomId } = ctx.params;
  const resolvedRoomId = await requireRoomMembership(ctx.env, roomId, ctx.user!.id);
  const suggestions = await all<{ id: string; kind: string; text: string; created_at: number }>(
    ctx.env.DB,
    'SELECT id, kind, text, created_at FROM suggestions WHERE room_id = ? ORDER BY created_at DESC LIMIT 20',
    [resolvedRoomId]
  );
  return jsonResponse({ suggestions });
}
````

## File: worker/src/auth.ts
````typescript
import { HandlerContext, AuthUser, Env } from './types';
import {
  readJson,
  jsonResponse,
  HttpError,
  ensure,
  encodeText,
  base64UrlEncode,
  decodeBase64Url,
  getUserRecord,
  toBase64,
  fromBase64,
  timingSafeEqual,
} from './utils';
import { first } from './db';
const SALT_LENGTH = 16;
const PBKDF2_ITERATIONS = 200000;
const PBKDF2_LENGTH = 32;
const textEncoder = new TextEncoder();
interface JwtPayload {
  sub: string;
  email: string;
  role: 'user' | 'admin';
  exp: number;
  iat: number;
}
export async function hashPassword(password: string, pepper: string): Promise<string> {
  const salt = crypto.getRandomValues(new Uint8Array(SALT_LENGTH));
  const derived = await deriveKey(password, pepper, salt, PBKDF2_ITERATIONS);
  return ['pbkdf2', PBKDF2_ITERATIONS, toBase64(salt), toBase64(derived)].join('$');
}
export async function verifyPassword(password: string, pepper: string, hash: string): Promise<boolean> {
  const parts = hash.split('$');
  if (parts.length !== 4 || parts[0] !== 'pbkdf2') {
    return false;
  }
  const iterations = Number(parts[1]);
  if (!Number.isSafeInteger(iterations) || iterations <= 0) {
    return false;
  }
  const salt = fromBase64(parts[2]);
  const expected = fromBase64(parts[3]);
  const actual = await deriveKey(password, pepper, salt, iterations);
  return timingSafeEqual(actual, expected);
}
export async function handleRegister(ctx: HandlerContext): Promise<Response> {
  const body = await readJson<{ email?: string; password?: string }>(ctx.request);
  const email = body.email?.trim().toLowerCase();
  const password = body.password?.trim();
  ensure(email && email.includes('@'), 400, 'Valid email required');
  ensure(password && password.length >= 6, 400, 'Password must be at least 6 chars');
  const existing = await first<{ id: string }>(ctx.env.DB, 'SELECT id FROM users WHERE email = ?', [email]);
  ensure(!existing, 409, 'Email already registered');
  const id = crypto.randomUUID();
  const passHash = await hashPassword(password!, ctx.env.PEPPER);
  const createdAt = Date.now();
  await ctx.env.DB
    .prepare('INSERT INTO users (id, email, pass_hash, role, created_at) VALUES (?, ?, ?, ?, ?)')
    .bind(id, email, passHash, 'user', createdAt)
    .run();
  const user: AuthUser = { id, email, role: 'user' };
  const jwt = await issueJwt(user, ctx.env);
  return jsonResponse({ user, jwt });
}
export async function handleLogin(ctx: HandlerContext): Promise<Response> {
  const body = await readJson<{ email?: string; password?: string }>(ctx.request);
  const email = body.email?.trim().toLowerCase();
  const password = body.password?.trim();
  ensure(email && password, 400, 'Email and password required');
  const record = await first<{ id: string; email: string; role: 'user' | 'admin'; pass_hash: string }>(
    ctx.env.DB,
    'SELECT id, email, role, pass_hash FROM users WHERE email = ?',
    [email]
  );
  ensure(record, 401, 'Invalid credentials');
  const valid = await verifyPassword(password!, ctx.env.PEPPER, record!.pass_hash);
  ensure(valid, 401, 'Invalid credentials');
  const user: AuthUser = { id: record!.id, email: record!.email, role: record!.role };
  const jwt = await issueJwt(user, ctx.env);
  return jsonResponse({ user, jwt });
}
export async function handleMe(ctx: HandlerContext): Promise<Response> {
  ensure(ctx.user, 401, 'Unauthorized');
  const dbUser = await getUserRecord(ctx.env, ctx.user!.id);
  ensure(dbUser, 401, 'User not found');
  return jsonResponse({ user: { id: dbUser!.id, email: dbUser!.email, role: dbUser!.role } });
}
export async function authenticateRequest(request: Request, env: Env): Promise<AuthUser | null> {
  const authHeader = request.headers.get('authorization');
  if (!authHeader) {
    return null;
  }
  const [, token] = authHeader.split(' ');
  if (!token) return null;
  const payload = await verifyJwt(token, env.JWT_SECRET);
  if (!payload) return null;
  return { id: payload.sub, email: payload.email, role: payload.role };
}
async function issueJwt(user: AuthUser, env: Env): Promise<string> {
  const ttl = Number(env.JWT_TTL_MINUTES ?? '15');
  const now = Math.floor(Date.now() / 1000);
  const payload: JwtPayload = {
    sub: user.id,
    email: user.email,
    role: user.role,
    iat: now,
    exp: now + ttl * 60,
  };
  return signJwt(payload, env.JWT_SECRET);
}
async function signJwt(payload: JwtPayload, secret: string): Promise<string> {
  const header = { alg: 'HS256', typ: 'JWT' };
  const headerBytes = encodeText(JSON.stringify(header));
  const payloadBytes = encodeText(JSON.stringify(payload));
  const encodedHeader = base64UrlEncode(headerBytes);
  const encodedPayload = base64UrlEncode(payloadBytes);
  const data = `${encodedHeader}.${encodedPayload}`;
  const keyBuffer = encodeText(secret).buffer as ArrayBuffer;
  const key = await crypto.subtle.importKey('raw', keyBuffer, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
  const dataBuffer = encodeText(data).buffer as ArrayBuffer;
  const signature = await crypto.subtle.sign('HMAC', key, dataBuffer);
  return `${data}.${base64UrlEncode(new Uint8Array(signature))}`;
}
async function verifyJwt(token: string, secret: string): Promise<JwtPayload | null> {
  const segments = token.split('.');
  if (segments.length !== 3) return null;
  const [encodedHeader, encodedPayload, encodedSignature] = segments;
  const data = `${encodedHeader}.${encodedPayload}`;
  const keyBuffer = encodeText(secret).buffer as ArrayBuffer;
  const key = await crypto.subtle.importKey('raw', keyBuffer, { name: 'HMAC', hash: 'SHA-256' }, false, ['verify']);
  const signatureBuffer = decodeBase64Url(encodedSignature).buffer as ArrayBuffer;
  const dataBuffer = encodeText(data).buffer as ArrayBuffer;
  const valid = await crypto.subtle.verify('HMAC', key, signatureBuffer, dataBuffer);
  if (!valid) return null;
  try {
    const payload = JSON.parse(new TextDecoder().decode(decodeBase64Url(encodedPayload)));
    if (!payload.exp || payload.exp < Math.floor(Date.now() / 1000)) {
      return null;
    }
    return payload as JwtPayload;
  } catch (err) {
    console.error('jwt parse failed', err);
    return null;
  }
}
function toArrayBuffer(bytes: Uint8Array): ArrayBuffer {
  const view = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
  return view as ArrayBuffer;
}
async function deriveKey(password: string, pepper: string, salt: Uint8Array, iterations: number): Promise<Uint8Array> {
  const keyMaterial = await crypto.subtle.importKey('raw', toArrayBuffer(encodeText(password + pepper)), 'PBKDF2', false, [
    'deriveBits',
  ]);
  const bits = await crypto.subtle.deriveBits(
    {
      name: 'PBKDF2',
      hash: 'SHA-256',
      salt: toArrayBuffer(salt),
      iterations,
    },
    keyMaterial,
    PBKDF2_LENGTH * 8
  );
  return new Uint8Array(bits);
}
````

## File: worker/src/db.ts
````typescript
export async function first<T>(db: D1Database, query: string, bindings: unknown[] = []): Promise<T | null> {
  const result = await db.prepare(query).bind(...bindings).first<T>();
  return (result as T) ?? null;
}
export async function all<T>(db: D1Database, query: string, bindings: unknown[] = []): Promise<T[]> {
  const { results } = await db.prepare(query).bind(...bindings).all<T>();
  return results as T[];
}
export async function run(db: D1Database, query: string, bindings: unknown[] = []) {
  return db.prepare(query).bind(...bindings).run();
}
````

## File: worker/src/index.ts
````typescript
import { Env, Handler, HandlerContext } from './types';
import { consumeRateLimit } from './kv';
import { jsonResponse, errorResponse, HttpError, getIp } from './utils';
import { handleRegister, handleLogin, handleMe, authenticateRequest } from './auth';
import {
  handleListRooms,
  handleGetRoom,
  handleCreateRoom,
  handleJoinRoom,
  handleListMessages,
  handlePostMessage,
  handleListTasks,
  handleCreateTask,
  handleUpdateTask,
  handlePostCheckin,
  handleGetCheckins,
} from './rooms';
import { handleCreateDevice, handleListDevices, handleIngest, handleGetReadings } from './iot';
import { handleGetSuggestions } from './agent';
interface Route {
  method: string;
  pattern: string;
  handler: Handler;
  auth?: 'optional' | 'user';
  skipRateLimit?: boolean;
}
const routes: Route[] = [
  { method: 'GET', pattern: '/health', handler: handleHealth, auth: 'optional', skipRateLimit: true },
  { method: 'POST', pattern: '/api/auth/register', handler: handleRegister, auth: 'optional' },
  { method: 'POST', pattern: '/api/auth/login', handler: handleLogin, auth: 'optional' },
  { method: 'GET', pattern: '/api/auth/me', handler: handleMe, auth: 'user' },
  { method: 'GET', pattern: '/api/rooms', handler: handleListRooms, auth: 'optional' },
  { method: 'GET', pattern: '/api/rooms/:roomId', handler: handleGetRoom, auth: 'optional' },
  { method: 'POST', pattern: '/api/rooms', handler: handleCreateRoom, auth: 'user' },
  { method: 'POST', pattern: '/api/rooms/:roomId/join', handler: handleJoinRoom, auth: 'user' },
  { method: 'GET', pattern: '/api/rooms/:roomId/messages', handler: handleListMessages, auth: 'user' },
  { method: 'POST', pattern: '/api/rooms/:roomId/messages', handler: handlePostMessage, auth: 'user' },
  { method: 'GET', pattern: '/api/rooms/:roomId/tasks', handler: handleListTasks, auth: 'user' },
  { method: 'POST', pattern: '/api/rooms/:roomId/tasks', handler: handleCreateTask, auth: 'user' },
  { method: 'PUT', pattern: '/api/tasks/:taskId', handler: handleUpdateTask, auth: 'user' },
  { method: 'POST', pattern: '/api/rooms/:roomId/checkins', handler: handlePostCheckin, auth: 'user' },
  { method: 'GET', pattern: '/api/rooms/:roomId/checkins', handler: handleGetCheckins, auth: 'user' },
  { method: 'GET', pattern: '/api/rooms/:roomId/readings', handler: handleGetReadings, auth: 'user' },
  { method: 'GET', pattern: '/api/rooms/:roomId/suggestions', handler: handleGetSuggestions, auth: 'user' },
  { method: 'POST', pattern: '/api/devices', handler: handleCreateDevice, auth: 'user' },
  { method: 'GET', pattern: '/api/devices', handler: handleListDevices, auth: 'user' },
  { method: 'POST', pattern: '/api/iot/ingest', handler: handleIngest, auth: 'optional', skipRateLimit: true },
];
const corsHeaders = {
  'access-control-allow-origin': '*',
  'access-control-allow-methods': 'GET,POST,PUT,OPTIONS',
  'access-control-allow-headers': 'content-type,authorization,x-device-secret',
};
export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    if (request.method === 'OPTIONS') {
      return new Response(null, { status: 204, headers: corsHeaders });
    }
    try {
      const url = new URL(request.url);
      const match = findRoute(request.method, url.pathname);
      if (!match) {
        return withCors(errorResponse('Not Found', 404));
      }
      if (!match.route.skipRateLimit) {
        const ip = getIp(request);
        const rate = await consumeRateLimit(env, `rate:${ip}`, 60, 60);
        if (!rate.allowed) {
          return withCors(errorResponse('Too many requests', 429));
        }
      }
      const user = await authenticateRequest(request, env);
      if (match.route.auth === 'user' && !user) {
        return withCors(errorResponse('Unauthorized', 401));
      }
      const ctxPayload: HandlerContext = {
        env,
        request,
        params: match.params,
        user: user ?? null,
        waitUntil: (promise) => ctx.waitUntil(promise),
      };
      const response = await match.route.handler(ctxPayload);
      return withCors(response);
    } catch (err) {
      if (err instanceof HttpError) {
        return withCors(errorResponse(err.message, err.status, err.details));
      }
      console.error('Unhandled worker error', err);
      return withCors(errorResponse('Internal Error', 500));
    }
  },
};
function withCors(response: Response): Response {
  const headers = new Headers(response.headers);
  Object.entries(corsHeaders).forEach(([key, value]) => headers.set(key, value));
  return new Response(response.body, { status: response.status, headers });
}
function findRoute(method: string, pathname: string) {
  for (const route of routes) {
    if (route.method !== method) continue;
    const params = matchPath(route.pattern, pathname);
    if (params) {
      return { route, params };
    }
  }
  return null;
}
function matchPath(pattern: string, pathname: string): Record<string, string> | null {
  const patternParts = trim(pattern).split('/');
  const pathParts = trim(pathname).split('/');
  if (patternParts.length !== pathParts.length) return null;
  const params: Record<string, string> = {};
  for (let i = 0; i < patternParts.length; i += 1) {
    const expected = patternParts[i];
    const actual = pathParts[i];
    if (expected.startsWith(':')) {
      params[expected.slice(1)] = decodeURIComponent(actual);
    } else if (expected !== actual) {
      return null;
    }
  }
  return params;
}
function trim(path: string): string {
  const clean = path.replace(/^\/+|\/+$|\s+/g, '');
  return clean ? clean : '';
}
async function handleHealth(ctx: HandlerContext): Promise<Response> {
  return jsonResponse({ ok: true });
}
````

## File: worker/src/iot.ts
````typescript
import { HandlerContext } from './types';
import { readJson, jsonResponse, ensure, nowMs, sha256Hex, clamp } from './utils';
import { all, first, run } from './db';
import { computeSuggestions } from './agent';
import { requireRoomMembership } from './access';
export async function handleCreateDevice(ctx: HandlerContext): Promise<Response> {
  ensure(ctx.user && ctx.user.role === 'admin', 403, 'Admin only');
  const body = await readJson<{ room_id?: string; name?: string; kind?: string }>(ctx.request);
  const roomKey = body.room_id?.trim();
  const name = body.name?.trim() ?? 'Env Beacon';
  ensure(roomKey, 400, 'room_id required');
  const room = await first<{ id: string }>(ctx.env.DB, 'SELECT id FROM rooms WHERE id = ? OR slug = ?', [roomKey, roomKey]);
  ensure(room, 404, 'Room not found');
  const deviceId = `device_${crypto.randomUUID().split('-')[0]}`;
  const secretPlain = generateSecret();
  const secretHash = await hashDeviceSecret(secretPlain, ctx.env.PEPPER);
  await run(
    ctx.env.DB,
    'INSERT INTO devices (id, room_id, name, kind, secret_hash, created_at) VALUES (?, ?, ?, ?, ?, ?)',
    [deviceId, room!.id, name, body.kind ?? 'environment', secretHash, nowMs()]
  );
  return jsonResponse({ device: { id: deviceId, room_id: room!.id, name, kind: body.kind ?? 'environment' }, secret: secretPlain }, { status: 201 });
}
export async function handleListDevices(ctx: HandlerContext): Promise<Response> {
  ensure(ctx.user && ctx.user.role === 'admin', 403, 'Admin only');
  const devices = await all<{ id: string; room_id: string; name: string; kind: string; created_at: number }>(
    ctx.env.DB,
    'SELECT id, room_id, name, kind, created_at FROM devices ORDER BY created_at DESC'
  );
  return jsonResponse({ devices });
}
export async function handleIngest(ctx: HandlerContext): Promise<Response> {
  const secret = ctx.request.headers.get('x-device-secret');
  ensure(secret, 401, 'Missing X-Device-Secret');
  const body = await readJson<{ device_id?: string; t_c?: number; noise_db?: number; lux?: number; ts?: number }>(ctx.request);
  const deviceId = body.device_id?.trim();
  ensure(deviceId, 400, 'device_id required');
  const device = await first<{ id: string; room_id: string; secret_hash: string }>(
    ctx.env.DB,
    'SELECT id, room_id, secret_hash FROM devices WHERE id = ?',
    [deviceId]
  );
  ensure(device, 404, 'Device not found');
  const hashed = await hashDeviceSecret(secret!, ctx.env.PEPPER);
  ensure(hashed === device!.secret_hash, 401, 'Invalid device secret');
  const createdAt = Number(body.ts) || nowMs();
  const tC = body.t_c ?? null;
  const noise = body.noise_db ?? null;
  const lux = body.lux ?? null;
  await run(
    ctx.env.DB,
    'INSERT INTO readings (id, device_id, room_id, t_c, noise_db, lux, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)',
    [crypto.randomUUID(), device!.id, device!.room_id, tC, noise, lux, createdAt]
  );
  await run(ctx.env.DB, 'DELETE FROM readings WHERE room_id = ? AND created_at < ?', [device!.room_id, nowMs() - 15 * 60 * 1000]);
  ctx.waitUntil(computeSuggestions(ctx.env, device!.room_id));
  return jsonResponse({ stored: true });
}
export async function handleGetReadings(ctx: HandlerContext): Promise<Response> {
  ensure(ctx.user, 401, 'Unauthorized');
  const { roomId } = ctx.params;
  const resolvedRoomId = await requireRoomMembership(ctx.env, roomId, ctx.user!.id);
  const url = new URL(ctx.request.url);
  const minutes = clamp(Number(url.searchParams.get('window') ?? '15'), 5, 60);
  const windowStart = nowMs() - minutes * 60 * 1000;
  const readings = await all<{
    id: string;
    device_id: string;
    t_c: number;
    noise_db: number;
    lux: number;
    created_at: number;
  }>(
    ctx.env.DB,
    'SELECT id, device_id, t_c, noise_db, lux, created_at FROM readings WHERE room_id = ? AND created_at >= ? ORDER BY created_at DESC LIMIT 200',
    [resolvedRoomId, windowStart]
  );
  const ordered = readings.reverse();
  const summary = summarizeReadings(ordered);
  return jsonResponse({ readings: ordered, summary });
}
function summarizeReadings(readings: Array<{ t_c: number; noise_db: number; lux: number }>) {
  if (!readings.length) return null;
  const sums = readings.reduce(
    (acc, row) => {
      if (typeof row.t_c === 'number') {
        acc.t_c.count += 1;
        acc.t_c.sum += row.t_c;
      }
      if (typeof row.noise_db === 'number') {
        acc.noise.count += 1;
        acc.noise.sum += row.noise_db;
      }
      if (typeof row.lux === 'number') {
        acc.lux.count += 1;
        acc.lux.sum += row.lux;
      }
      return acc;
    },
    {
      t_c: { sum: 0, count: 0 },
      noise: { sum: 0, count: 0 },
      lux: { sum: 0, count: 0 },
    }
  );
  const avg = (sum: number, count: number) => (count ? Number((sum / count).toFixed(1)) : null);
  return {
    avg_t_c: avg(sums.t_c.sum, sums.t_c.count),
    avg_noise_db: avg(sums.noise.sum, sums.noise.count),
    avg_lux: avg(sums.lux.sum, sums.lux.count),
  };
}
function generateSecret(): string {
  const bytes = crypto.getRandomValues(new Uint8Array(16));
  return Array.from(bytes)
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('');
}
async function hashDeviceSecret(secret: string, pepper: string): Promise<string> {
  return sha256Hex(`${secret}${pepper}`);
}
````

## File: worker/src/kv.ts
````typescript
import { Env } from './types';
export interface RateLimitResult {
  allowed: boolean;
  remaining: number;
}
export async function consumeRateLimit(env: Env, key: string, limit: number, windowSeconds: number): Promise<RateLimitResult> {
  const windowKey = `${key}:${Math.floor(Date.now() / 1000 / windowSeconds)}`;
  const currentRaw = await env.KV.get(windowKey);
  const current = currentRaw ? Number(currentRaw) : 0;
  if (current >= limit) {
    return { allowed: false, remaining: 0 };
  }
  await env.KV.put(windowKey, String(current + 1), { expirationTtl: windowSeconds });
  return { allowed: true, remaining: Math.max(0, limit - current - 1) };
}
export async function throttle(env: Env, key: string, ttlSeconds: number): Promise<boolean> {
  const exists = await env.KV.get(key);
  if (exists) {
    return false;
  }
  await env.KV.put(key, '1', { expirationTtl: ttlSeconds });
  return true;
}
export async function incrementCounter(env: Env, key: string, ttlSeconds?: number) {
  const currentRaw = await env.KV.get(key);
  const current = currentRaw ? Number(currentRaw) : 0;
  const next = current + 1;
  await env.KV.put(key, String(next), ttlSeconds ? { expirationTtl: ttlSeconds } : undefined);
  return next;
}
````

## File: worker/src/rooms.ts
````typescript
import { HandlerContext } from './types';
import { readJson, jsonResponse, ensure, slugify, randomId, escapeHtml, clamp, nowMs } from './utils';
import { all, first, run } from './db';
import { throttle } from './kv';
import { computeSuggestions } from './agent';
import { requireRoomMembership } from './access';
export async function handleListRooms(ctx: HandlerContext): Promise<Response> {
  const rooms = await all<{ id: string; name: string; slug: string; map_seed: string }>(
    ctx.env.DB,
    'SELECT id, name, slug, map_seed FROM rooms ORDER BY created_at ASC'
  );
  return jsonResponse({ rooms });
}
export async function handleGetRoom(ctx: HandlerContext): Promise<Response> {
  const { roomId } = ctx.params;
  const room = await first<{ id: string; name: string; slug: string; map_seed: string }>(
    ctx.env.DB,
    'SELECT id, name, slug, map_seed FROM rooms WHERE id = ? OR slug = ?',
    [roomId, roomId]
  );
  ensure(room, 404, 'Room not found');
  return jsonResponse({ room });
}
export async function handleCreateRoom(ctx: HandlerContext): Promise<Response> {
  ensure(ctx.user && ctx.user.role === 'admin', 403, 'Admin only');
  const body = await readJson<{ name?: string; map_seed?: string }>(ctx.request);
  const name = body.name?.trim();
  ensure(name && name.length >= 3, 400, 'Room name required');
  const baseSlug = slugify(name) || `room-${randomId('slug').split('_')[1]}`;
  let slug = baseSlug;
  let attempt = 1;
  while (true) {
    const exists = await first<{ id: string }>(ctx.env.DB, 'SELECT id FROM rooms WHERE slug = ?', [slug]);
    if (!exists) break;
    slug = `${baseSlug}-${attempt++}`;
  }
  const id = crypto.randomUUID();
  await run(
    ctx.env.DB,
    'INSERT INTO rooms (id, name, slug, map_seed, created_at) VALUES (?, ?, ?, ?, ?)',
    [id, name, slug, body.map_seed ?? null, nowMs()]
  );
  return jsonResponse({ room: { id, name, slug, map_seed: body.map_seed ?? null } }, { status: 201 });
}
export async function handleJoinRoom(ctx: HandlerContext): Promise<Response> {
  ensure(ctx.user, 401, 'Unauthorized');
  const { roomId } = ctx.params;
  const room = await first<{ id: string }>(ctx.env.DB, 'SELECT id FROM rooms WHERE id = ? OR slug = ?', [roomId, roomId]);
  ensure(room, 404, 'Room not found');
  await run(
    ctx.env.DB,
    'INSERT OR IGNORE INTO room_members (user_id, room_id, joined_at) VALUES (?, ?, ?)',
    [ctx.user!.id, room!.id, nowMs()]
  );
  return jsonResponse({ joined: true });
}
export async function handleListMessages(ctx: HandlerContext): Promise<Response> {
  ensure(ctx.user, 401, 'Unauthorized');
  const { roomId } = ctx.params;
  const resolvedRoomId = await requireRoomMembership(ctx.env, roomId, ctx.user!.id);
  const url = new URL(ctx.request.url);
  const cursor = Number(url.searchParams.get('cursor') ?? '0');
  const limit = clamp(Number(url.searchParams.get('limit') ?? '50'), 1, 200);
  const rows = await all<{
    id: string;
    body: string;
    created_at: number;
    user_id: string;
    email: string;
  }>(
    ctx.env.DB,
    `SELECT m.id, m.body, m.created_at, u.id as user_id, u.email
     FROM messages m
     JOIN users u ON u.id = m.user_id
     WHERE m.room_id = ? AND m.created_at < CASE WHEN ? = 0 THEN 9223372036854775807 ELSE ? END
     ORDER BY m.created_at DESC
     LIMIT ?`,
    [resolvedRoomId, cursor, cursor, limit]
  );
  return jsonResponse({
    messages: rows.reverse(),
    nextCursor: rows.length ? rows[0].created_at : null,
  });
}
export async function handlePostMessage(ctx: HandlerContext): Promise<Response> {
  ensure(ctx.user, 401, 'Unauthorized');
  const { roomId } = ctx.params;
  const resolvedRoomId = await requireRoomMembership(ctx.env, roomId, ctx.user!.id);
  const body = await readJson<{ body?: string }>(ctx.request, 2 * 1024);
  const message = body.body?.trim();
  ensure(message && message.length, 400, 'Message body required');
  ensure(message.length <= 512, 400, 'Message too long');
  const throttleKey = `msg:${ctx.user!.id}:${resolvedRoomId}`;
  const allowed = await throttle(ctx.env, throttleKey, 2);
  ensure(allowed, 429, 'Slow down');
  const html = escapeHtml(message);
  const id = crypto.randomUUID();
  const createdAt = nowMs();
  await run(ctx.env.DB, 'INSERT INTO messages (id, room_id, user_id, body, created_at) VALUES (?, ?, ?, ?, ?)', [
    id,
    resolvedRoomId,
    ctx.user!.id,
    html,
    createdAt,
  ]);
  return jsonResponse({ message: { id, body: html, created_at: createdAt } }, { status: 201 });
}
export async function handleListTasks(ctx: HandlerContext): Promise<Response> {
  ensure(ctx.user, 401, 'Unauthorized');
  const { roomId } = ctx.params;
  const resolvedRoomId = await requireRoomMembership(ctx.env, roomId, ctx.user!.id);
  const tasks = await all<{
    id: string;
    title: string;
    status: string;
    assignee_id: string | null;
    created_at: number;
  }>(
    ctx.env.DB,
    'SELECT id, title, status, assignee_id, created_at FROM tasks WHERE room_id = ? ORDER BY created_at DESC',
    [resolvedRoomId]
  );
  return jsonResponse({ tasks });
}
export async function handleCreateTask(ctx: HandlerContext): Promise<Response> {
  ensure(ctx.user, 401, 'Unauthorized');
  const { roomId } = ctx.params;
  const resolvedRoomId = await requireRoomMembership(ctx.env, roomId, ctx.user!.id);
  const body = await readJson<{ title?: string; assignee_id?: string }>(ctx.request);
  const title = body.title?.trim();
  ensure(title && title.length >= 3, 400, 'Task title required');
  const id = crypto.randomUUID();
  await run(
    ctx.env.DB,
    'INSERT INTO tasks (id, room_id, title, status, assignee_id, created_at) VALUES (?, ?, ?, ?, ?, ?)',
    [id, resolvedRoomId, title, 'todo', body.assignee_id ?? null, nowMs()]
  );
  return jsonResponse({ task: { id, title, status: 'todo', assignee_id: body.assignee_id ?? null } }, { status: 201 });
}
export async function handleUpdateTask(ctx: HandlerContext): Promise<Response> {
  ensure(ctx.user, 401, 'Unauthorized');
  const { taskId } = ctx.params;
  const task = await first<{ id: string; room_id: string }>(ctx.env.DB, 'SELECT id, room_id FROM tasks WHERE id = ?', [taskId]);
  ensure(task, 404, 'Task not found');
  await requireRoomMembership(ctx.env, task!.room_id, ctx.user!.id);
  const body = await readJson<{ status?: string; assignee_id?: string | null }>(ctx.request);
  const status = body.status ?? undefined;
  if (status) {
    ensure(['todo', 'doing', 'done'].includes(status), 400, 'Invalid status');
  }
  await run(
    ctx.env.DB,
    'UPDATE tasks SET status = COALESCE(?, status), assignee_id = ? WHERE id = ?',
    [status ?? null, body.assignee_id ?? null, taskId]
  );
  const updated = await first(ctx.env.DB, 'SELECT id, room_id, title, status, assignee_id FROM tasks WHERE id = ?', [taskId]);
  return jsonResponse({ task: updated });
}
export async function handlePostCheckin(ctx: HandlerContext): Promise<Response> {
  ensure(ctx.user, 401, 'Unauthorized');
  const { roomId } = ctx.params;
  const resolvedRoomId = await requireRoomMembership(ctx.env, roomId, ctx.user!.id);
  const body = await readJson<{ mood?: number; energy?: number; status?: string }>(ctx.request);
  const mood = clamp(Number(body.mood ?? 3), 1, 5);
  const energy = clamp(Number(body.energy ?? 3), 1, 5);
  const status = body.status ?? 'focus';
  ensure(['focus', 'solo', 'pair', 'afk'].includes(status), 400, 'Invalid status');
  const id = crypto.randomUUID();
  const createdAt = nowMs();
  await run(
    ctx.env.DB,
    'INSERT INTO checkins (id, user_id, room_id, mood, energy, status, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)',
    [id, ctx.user!.id, resolvedRoomId, mood, energy, status, createdAt]
  );
  ctx.env.KV.put(`presence:${resolvedRoomId}:${ctx.user!.id}`, JSON.stringify({ status, mood, energy, at: createdAt }), {
    expirationTtl: 1800,
  });
  ctx.waitUntil(computeSuggestions(ctx.env, resolvedRoomId));
  return jsonResponse({ ok: true });
}
export async function handleGetCheckins(ctx: HandlerContext): Promise<Response> {
  ensure(ctx.user, 401, 'Unauthorized');
  const { roomId } = ctx.params;
  const resolvedRoomId = await requireRoomMembership(ctx.env, roomId, ctx.user!.id);
  const url = new URL(ctx.request.url);
  const sinceMs = Number(url.searchParams.get('since') ?? 0);
  const windowStart = sinceMs || nowMs() - 30 * 60 * 1000;
  const checkins = await all<{
    id: string;
    user_id: string;
    email: string;
    mood: number;
    energy: number;
    status: string;
    created_at: number;
  }>(
    ctx.env.DB,
    `SELECT c.id, c.user_id, u.email, c.mood, c.energy, c.status, c.created_at
     FROM checkins c
     JOIN users u ON u.id = c.user_id
     WHERE c.room_id = ? AND c.created_at >= ?
     ORDER BY c.created_at DESC`,
    [resolvedRoomId, windowStart]
  );
  return jsonResponse({ checkins });
}
````

## File: worker/src/types.ts
````typescript
export interface Env {
  DB: D1Database;
  KV: KVNamespace;
  JWT_SECRET: string;
  PEPPER: string;
  JWT_TTL_MINUTES?: string;
  ZAI_API_KEY?: string;
}
export interface AuthUser {
  id: string;
  email: string;
  role: 'user' | 'admin';
}
export interface HandlerContext {
  env: Env;
  request: Request;
  params: Record<string, string>;
  user: AuthUser | null;
  waitUntil: (promise: Promise<unknown>) => void;
}
export type Handler = (ctx: HandlerContext) => Promise<Response>;
````

## File: worker/src/utils.ts
````typescript
import { Env } from './types';
const encoder = new TextEncoder();
const decoder = new TextDecoder();
export class HttpError extends Error {
  status: number;
  details?: unknown;
  constructor(status: number, message: string, details?: unknown) {
    super(message);
    this.status = status;
    this.details = details;
  }
}
export function jsonResponse(data: unknown, init: ResponseInit = {}): Response {
  return new Response(JSON.stringify(data), {
    headers: {
      'content-type': 'application/json; charset=utf-8',
      ...init.headers,
    },
    status: init.status ?? 200,
  });
}
export function errorResponse(message: string, status = 400, details?: unknown): Response {
  return jsonResponse({ error: message, details }, { status });
}
export async function readJson<T>(request: Request, limit = 32 * 1024): Promise<T> {
  const lengthHeader = request.headers.get('content-length');
  if (lengthHeader && Number(lengthHeader) > limit) {
    throw new HttpError(413, 'Payload too large');
  }
  const buffer = await request.arrayBuffer();
  if (buffer.byteLength > limit) {
    throw new HttpError(413, 'Payload too large');
  }
  if (!buffer.byteLength) {
    return {} as T;
  }
  const text = decoder.decode(buffer);
  if (!text.trim()) {
    return {} as T;
  }
  try {
    return JSON.parse(text);
  } catch (err) {
    throw new HttpError(400, 'Invalid JSON');
  }
}
export function slugify(input: string): string {
  return input
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .replace(/-{2,}/g, '-');
}
export function escapeHtml(input: string): string {
  return input
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}
export function nowMs(): number {
  return Date.now();
}
export function randomId(prefix: string): string {
  const fragment = crypto.randomUUID().replace(/-/g, '').slice(0, 8);
  return `${prefix}_${fragment}`;
}
export function getIp(request: Request): string {
  return (
    request.headers.get('cf-connecting-ip') ||
    request.headers.get('x-real-ip') ||
    request.headers.get('x-forwarded-for') ||
    'unknown'
  );
}
export async function sha256Hex(input: string): Promise<string> {
  const bytes = encoder.encode(input);
  const digest = await crypto.subtle.digest('SHA-256', bytes);
  return bufferToHex(new Uint8Array(digest));
}
export function bufferToHex(bytes: Uint8Array): string {
  return Array.from(bytes)
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('');
}
export function base64UrlEncode(data: Uint8Array): string {
  let str = '';
  data.forEach((byte) => {
    str += String.fromCharCode(byte);
  });
  return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
}
export function encodeText(input: string): Uint8Array {
  return encoder.encode(input);
}
export function decodeBase64Url(input: string): Uint8Array {
  const padLength = (4 - (input.length % 4)) % 4;
  const normalized = input.replace(/-/g, '+').replace(/_/g, '/') + '='.repeat(padLength);
  const str = atob(normalized);
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i += 1) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}
export function minutesToMs(minutes: number): number {
  return minutes * 60 * 1000;
}
export function ensure(condition: unknown, status: number, message: string): asserts condition {
  if (!condition) {
    throw new HttpError(status, message);
  }
}
export function parseNumber(input: string | null, fallback: number): number {
  if (!input) return fallback;
  const parsed = Number(input);
  return Number.isFinite(parsed) ? parsed : fallback;
}
export function clamp(value: number, min: number, max: number): number {
  return Math.min(Math.max(value, min), max);
}
export async function fetchJson<T>(request: Request): Promise<T> {
  return readJson<T>(request);
}
export async function getUserRecord(env: Env, id: string) {
  const result = await env.DB.prepare('SELECT id, email, role, created_at FROM users WHERE id = ?').bind(id).first();
  return result as { id: string; email: string; role: 'user' | 'admin'; created_at: number } | null;
}
export function toBase64(bytes: Uint8Array): string {
  if (typeof btoa === 'function') {
    let binary = '';
    bytes.forEach((b) => {
      binary += String.fromCharCode(b);
    });
    return btoa(binary);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore Buffer is available in Node (tests)
  return Buffer.from(bytes).toString('base64');
}
export function fromBase64(input: string): Uint8Array {
  if (typeof atob === 'function') {
    const binary = atob(input);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i += 1) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
  }
  const buf = Buffer.from(input, 'base64');
  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
}
export function timingSafeEqual(a: Uint8Array, b: Uint8Array): boolean {
  if (a.length !== b.length) return false;
  let diff = 0;
  for (let i = 0; i < a.length; i += 1) {
    diff |= a[i] ^ b[i];
  }
  return diff === 0;
}
````

## File: worker/test/agent.test.ts
````typescript
import { describe, expect, it } from 'vitest';
import { buildCandidates } from '../src/agent';
describe('agent heuristics', () => {
  it('suggests move when noise high + low energy', () => {
    const readings = [{ noise_db: 70, t_c: 25, lux: 400, created_at: Date.now() }];
    const checkins = [{ user_id: 'u1', energy: 2, mood: 3, status: 'focus', created_at: Date.now() }];
    const suggestions = buildCandidates(readings as any, checkins as any);
    expect(suggestions.some((s) => s.kind === 'move')).toBe(true);
  });
  it('suggests pause when temp high and mood low', () => {
    const readings = [{ noise_db: 50, t_c: 29, lux: 450, created_at: Date.now() }];
    const checkins = [{ user_id: 'u2', energy: 4, mood: 1, status: 'focus', created_at: Date.now() }];
    const suggestions = buildCandidates(readings as any, checkins as any);
    expect(suggestions.some((s) => s.kind === 'pause')).toBe(true);
  });
});
````

## File: worker/test/auth.test.ts
````typescript
import { webcrypto } from 'node:crypto';
import { describe, expect, it, beforeAll } from 'vitest';
import { hashPassword, verifyPassword } from '../src/auth';
beforeAll(() => {
  Object.defineProperty(globalThis, 'crypto', {
    value: webcrypto,
    configurable: true,
  });
});
describe('auth hashing', () => {
  it('hashes and verifies a password with pepper', async () => {
    const hash = await hashPassword('secret123', 'pepper');
    const valid = await verifyPassword('secret123', 'pepper', hash);
    expect(valid).toBe(true);
  });
  it('fails for wrong password', async () => {
    const hash = await hashPassword('secret123', 'pepper');
    const valid = await verifyPassword('secret124', 'pepper', hash);
    expect(valid).toBe(false);
  });
});
````

## File: worker/.dev.vars
````
JWT_SECRET=dev-jwt-secret-please-change
PEPPER=dev-pepper
````

## File: worker/wrangler.toml
````toml
name = "holo-work"
main = "src/index.ts"
compatibility_date = "2025-11-10"
compatibility_flags = ["nodejs_compat"]
workers_dev = true

[vars]
JWT_TTL_MINUTES = "15"

[[d1_databases]]
binding = "DB"
database_name = "holo_work"
database_id = "4911f880-cd22-4064-bfce-f17a5aac42eb"

[[kv_namespaces]]
binding = "KV"
id = "5584069c6e5943b5a08621671e70ed3a"
````

## File: .editorconfig
````
root = true

[*]
end_of_line = lf
insert_final_newline = true
charset = utf-8
indent_style = space
indent_size = 2
trim_trailing_whitespace = true

[*.{ts,js,json,html,css,md}]
indent_size = 2
````

## File: .gitignore
````
node_modules/
.wrangler/
dist/
.vscode/
.DS_Store
*.log
coverage/
.venv/
````

## File: AGENTS.md
````markdown
# agents.md — holo.work (para codex)

## objetivo

gerar v1 funcional no nosso stack (cloudflare workers + d1 + kv + html/css/js), com admin local e iot_sim. evitar frameworks.

## layout do repo

```
/worker                 # api (ts)
  /src
    index.ts            # router
    auth.ts             # login/register/jwt
    rooms.ts            # rooms/messages/tasks
    iot.ts              # devices/ingest
    agent.ts            # sugestões
    db.ts               # d1 helpers
    kv.ts               # rate-limit/counters
  wrangler.toml
/sql
  schema.sql
  seed.sql
/ui                     # static pages (pages)
  index.html            # login
  room.html             # mapa/presença/chat/tasks
  admin.html            # admin local (sem auth externa)
  /css
  /js
/scripts
  iot_sim.py            # simulador
/docs
  PRD.md
  TODO.md
```

## padrões

* ts alvo: workers runtime. nenhuma lib além do que for estritamente necessário.
* ui: es modules, fetch, canvas 2d simples ou dom.
* css: utilitário leve (próprio). sem tailwind.
* commits: curtos, escopados.

## wrangler.toml (base)

```toml
name = "holo-work"
main = "worker/src/index.ts"
compatibility_date = "2025-11-10"

[[d1_databases]]
binding = "DB"
database_name = "holo_work"
database_id = "REPLACE"

[[kv_namespaces]]
binding = "KV"
id = "REPLACE"
```

## bootstrap

* criar tabelas com /sql/schema.sql via `wrangler d1 execute`.
* seeds mínimos: 1 admin, 2 rooms, 1 device com secret.

## rotas obrigatórias

implementar exatamente conforme prd (auth, rooms, messages, tasks, checkins, devices, iot/ingest, suggestions).

## lógica do agente

exportar `computeSuggestions(room_id)` que:

* busca últimos 15min de readings + últimos 30min de checkins.
* aplica heurísticas e grava em `suggestions` se ainda não existir similar em 10min.
* idempotente.

## ui

* index.html: login -> salvar jwt em memory + sessionStorage.
* room.html:

  * left: mapa e presenças (bolinhas com iniciais).
  * right tabs: chat, tasks, ambiente (temp/noise/lux), sugestões.
  * check-in top: slider mood/energy + select status.
* admin.html: forms simples para criar room/device e listar secrets (somente local, gated por `?local=1`).

## iot_sim.py

* lê env `INGEST_URL`, `DEVICE_ID`, `DEVICE_SECRET`.
* envia a cada 5s: t_c (20..32 com ruído), noise_db (40..75), lux (50..600).

## testes

* unit: função de hash/verify; função de agente.
* e2e: curl script: registrar, login, criar room (admin), postar msg, ingest, ler sugestões.
* evidências: salvar stdout para pdf.

## build ordem (one-shot)

1. schema + seed.
2. auth + jwt.
3. rooms + messages + tasks + checkins.
4. devices + ingest.
5. agent.
6. ui minimal.
7. iot_sim.
8. rate-limit + sane.
9. deploy.

## envs (names only)

JWT_SECRET, PEPPER, ZAI_API_KEY

## deploy

* `wrangler dev` local.
* `wrangler publish` prod.
* pages para `/ui` ou servir `/ui` estático via worker.

## geração de assets (opcional)

* endpoint `/api/assets/avatar?seed=xyz` → gera sprite 2d procedural (sem ia) v1.
* se `ZAI_API_KEY` existir, stub para futura geração com ia (não bloquear mvp).

## fiap-mode

* manter branch `fiap-mode` com mesmas rotas e pdf mapeando requisitos.

---
````

## File: CHANGELOG.md
````markdown
# Changelog

## 2025-02-10
- bootstrap repo layout (worker/ui/sql/scripts/docs)
- add base docs + checklist + config files
- add D1 schema/seed, worker auth/rooms/iot/agent routes, rate-limit + JSON guards
- ship static UI (login/room/admin), CSS utility, ES modules
- add IoT simulator script + vitest coverage for hashing + agent heuristics
- replace Argon2 (blocked by WASM restrictions in local dev) with PBKDF2-SHA256 + peppered storage until WASM pipeline is in place
````

## File: LICENSE
````
MIT License

Copyright (c) 2025 Daniel Alexandre Barcellos de Brito

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to do so, subject to the
following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
````

## File: p.md
````markdown
nice. deploy is mostly green. couple fixes + the pixel-asset flow:

### 0) upgrade + bindings

```
npm i -g wrangler@4.47.0
```

drop the kv id into `worker/wrangler.toml` → `kv_namespaces` (id was printed: `077d828e...ae1`). keep `DB` binding name as `holo_work`. 

### 1) secrets / tokens (dev + prod)

local dev: set in `worker/.dev.vars`. prod: use wrangler secrets.

```
# randoms
openssl rand -base64 48 | tr -d '\n'   # use as JWT_SECRET
openssl rand -base64 48 | tr -d '\n'   # use as PEPPER

# prod
npx wrangler secret put JWT_SECRET --config worker/wrangler.toml
npx wrangler secret put PEPPER --config worker/wrangler.toml
# optional ai
npx wrangler secret put GEMINI_API_KEY --config worker/wrangler.toml
npx wrangler secret put OPENROUTER_API_KEY --config worker/wrangler.toml
```

readme notes using `dev-pepper` locally so the seeded admin hash matches. so: set `PEPPER=dev-pepper` in `.dev.vars` for local runs. 

### 2) seed error (remote txn)

remote `d1 execute` choked on `BEGIN TRANSACTION` in `sql/seed.sql`. fast fixes:

* **easiest**: run seed **locally** (no `--remote`) with config flag:

```
npx wrangler d1 execute holo_work --config worker/wrangler.toml --file=sql/schema.sql
npx wrangler d1 execute holo_work --config worker/wrangler.toml --file=sql/seed.sql
```

(readme shows local apply) 

* **or** make `sql/seed.nobegin.sql` (same file without `BEGIN/COMMIT`) and execute that with `--remote`. the current seed has `BEGIN TRANSACTION; ... COMMIT;`. 

### 3) 404 on `/api/assets/avatar`

route isn’t implemented yet; ui already calls it. add a tiny deterministic svg “pixel” identicon so we’ve got avatars for chat/presença and tiles later.

**worker/src/index.ts** (add before the default 404):

```ts
if (url.pathname === "/api/assets/avatar") {
  const seed = (url.searchParams.get("seed") || "anon").trim();
  const s = Math.max(16, Math.min(512, +(url.searchParams.get("s")||"128")));
  // 5x5 mirror grid → svg
  const h = new Uint32Array(5);
  let x=2166136261; for (let i=0;i<seed.length;i++) { x ^= seed.charCodeAt(i); x = Math.imul(x,16777619); }
  for (let i=0;i<5;i++){ x ^= x<<13; x ^= x>>>17; x ^= x<<5; h[i]=x>>>0; }
  const cell = Math.floor(s/5);
  const fg = `hsl(${h[0]%360} 70% 45%)`, bg = "#0f1220";
  let rects = `<rect width="${s}" height="${s}" fill="${bg}"/>`;
  for (let r=0;r<5;r++){
    for (let c=0;c<3;c++){
      const bit = (h[r]>>(c*3))&1;
      if (!bit) continue;
      const x1=c*cell, x2=(4-c)*cell, y=r*cell;
      const rr = `<rect x="%x" y="${y}" width="${cell}" height="${cell}" rx="${Math.floor(cell*0.15)}" fill="${fg}"/>`;
      rects += rr.replace("%x", String(x1)) + rr.replace("%x", String(x2));
    }
  }
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${s} ${s}" width="${s}" height="${s}">${rects}</svg>`;
  return new Response(svg, { headers: { "content-type": "image/svg+xml", "cache-control":"public, max-age=31536000" }});
}
```

now the `/api/assets/avatar?seed=foo&s=128` calls in the log will return images. route exists in prd as “optional assets”, so this wires it for real. (prd/docs mention assets endpoint as optional; deploy doc shows static-ui note.) 

### 4) pixel art pipeline (tiles/sprites)

minimal, fast, reversible:

* folder: `ui/assets/tiles/`

  * `floor.png` `wall.png` `desk.png` `plant.png` etc, all **16×16** or **32×32**.
* atlas json (optional v1): `ui/assets/tiles/atlas.json` → name → x,y,w,h if packing later.
* render: keep the current 2d canvas map; load tiles once, draw by indices from a `map_seed` (string like `grid:16x16:hub`) → translate to a 2d int grid. map_seed already sits in `rooms.map_seed`. 

quick asset sources:

* aseprite export → 16×16 pngs
* kenney roguelike packs (cc0) → trim to 16×16

### 5) gemini/openrouter generate (v1 dev-mode)

wire a **dev-only** passthrough (rate-limited per ip in kv) for prototyping npc avatars/backgrounds:

**worker/src/index.ts** (sketch):

```ts
if (url.pathname==="/api/assets/generate" && req.method==="POST") {
  if (env.OPENROUTER_API_KEY) {
    const body = await req.json();
    const r = await fetch("https://openrouter.ai/api/v1/chat/completions", {
      method:"POST",
      headers:{ "authorization":`Bearer ${env.OPENROUTER_API_KEY}`, "content-type":"application/json" },
      body: JSON.stringify({
        model: "google/gemini-2.5-flash-image-preview",
        messages:[{role:"user", content: body.prompt }],
        modalities: ["image","text"],
        image_config: { aspect_ratio: "1:1" }
      })
    });
    const j = await r.json();
    return Response.json(j);
  }
  if (env.GEMINI_API_KEY) {
    const r = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:streamGenerateContent?key=${env.GEMINI_API_KEY}`, {
      method:"POST", headers:{ "content-type":"application/json" },
      body: JSON.stringify({ contents:[{role:"user", parts:[{text: (await req.json()).prompt}]}], generationConfig:{ responseModalities:["IMAGE","TEXT"], imageConfig:{ image_size:"1K" }}})
    });
    return new Response(await r.text(), { headers:{ "content-type":"application/json" }});
  }
  return new Response("image gen not configured", { status: 501 });
}
```

policy: v1 dev → only for us; v2 → same but rate-limited and behind a feature flag; v3 → byo key path; v4 → paid tier with our key + byok fallback. matches the staged plan. (deploy doc already has secrets step; extend it to include these two keys.) 

### 6) end-to-end checklist

1. wrangler 4.47.0, bindings up to date.
2. local seed without `--remote` **or** remote seed without the transaction block.
3. secrets: set local `.dev.vars` (`PEPPER=dev-pepper`, `JWT_SECRET=<rand>`). prod via `wrangler secret`. 
4. add `/api/assets/avatar` route (above).
5. drop initial tiles in `ui/assets/tiles/*`, load them in `room.js` to render the map.
6. optional: `/api/assets/generate` for image-gen dev mode (kv rate limit later).

### 7) sanity probes

```
curl http://127.0.0.1:8787/api/rooms
curl -I "http://127.0.0.1:8787/api/assets/avatar?seed=dan&s=128"
```

deploy guide smoke calls are already listed. 

small `docs/ASSETS.md` with tile specs + palette so art stays coherent with the ui grid.

---

arq
https://www.figma.com/board/RnpSFs6Rj2zN0iZb2tXIOD/holo.work-%E2%80%94-arquitetura?node-id=0-1&p=f&t=VWsvSS78qQ1gCTcg-0
flow
https://www.figma.com/board/NNopmsqV4eYfyfd5nySpRw/holo.work-%E2%80%94-fluxo-principal?node-id=0-1&p=f&t=iG38V2JQwoyfJE1M-0
iot_ingestion
https://www.figma.com/board/mylZk4aj3JyOLpGGkBRlSu/holo.work-%E2%80%94-ingest%C3%A3o-iot?node-id=0-1&p=f&t=2DMRjlxAXgXkMxgB-0
agent flow
https://www.figma.com/board/3xvZqC9J1M4GLaLdsNPxiQ/holo.work-%E2%80%94-agente--heur%C3%ADstica-v1-?node-id=0-1&p=f&t=vpBNqo9dF7BoIBS6-0
endpoints
https://www.figma.com/board/z6YClh3FALBOUO9w3RJStd/holo.work-%E2%80%94-endpoints?node-id=0-1&p=f&t=pnMyQjh6VPEO661z-0
states
https://www.figma.com/board/jNwcCSkh9w1BCVxbgYzbte/holo.work-%E2%80%94-estados-de-presen%C3%A7a?node-id=0-1&p=f&t=a47lx0mnsAQObMfl-0
deploy
https://www.figma.com/board/QAiEky9luSHOt6u4moFLea/holo.work-%E2%80%94-deploy?node-id=0-1&p=f&t=t7kQnDRCOIKkI5cD-0
````

## File: package.json
````json
{
  "name": "holo-work",
  "version": "0.1.0",
  "description": "Hybrid workspace hub with presence, chat, tasks, IoT comfort data, and actionable agent nudges. Cloudflare Workers + D1 + KV.",
  "type": "module",
  "main": "worker/src/index.ts",
  "scripts": {
    "dev": "wrangler dev --config worker/wrangler.toml",
    "deploy": "wrangler publish --config worker/wrangler.toml",
    "typecheck": "tsc --noEmit",
    "test": "vitest run",
    "test:watch": "vitest watch"
  },
  "keywords": [
    "cloudflare",
    "workers",
    "iot",
    "agent",
    "collaboration"
  ],
  "author": "Daniel Alexandre Barcellos de Brito",
  "license": "MIT",
  "devDependencies": {
    "@cloudflare/workers-types": "^4.20240208.0",
    "@types/node": "^24.10.0",
    "typescript": "^5.4.0",
    "vitest": "^1.3.1",
    "wrangler": "^4.46.0"
  }
}
````

## File: tsconfig.json
````json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ES2020",
    "lib": ["ES2020", "WebWorker"],
    "moduleResolution": "Bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "types": ["@cloudflare/workers-types"],
    "resolveJsonModule": true,
    "allowImportingTsExtensions": true,
    "noEmit": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": "."
  },
  "include": ["worker/src", "worker/test"]
}
````

## File: docs/DEPLOY.md
````markdown
# Deploy Guide

## Prereqs
- Cloudflare account with Workers + D1 + KV enabled
- `wrangler` (v4+) installed locally
- D1 + KV resources already created (see `worker/wrangler.toml` bindings)

## Steps
1. **Secrets**
   ```bash
   npx wrangler secret put JWT_SECRET --config worker/wrangler.toml
   npx wrangler secret put PEPPER --config worker/wrangler.toml
   # optional
   npx wrangler secret put ZAI_API_KEY --config worker/wrangler.toml
   ```
2. **Database schema + seed**
   ```bash
   npx wrangler d1 execute holo_work --config worker/wrangler.toml --file=sql/schema.sql --remote
   npx wrangler d1 execute holo_work --config worker/wrangler.toml --file=sql/seed.sql --remote
   ```
3. **Publish Worker**
   ```bash
   npx wrangler deploy --config worker/wrangler.toml
   ```
4. **Static UI**
   - Option A (Pages): deploy `ui/` as a Pages project; set API origin to the Worker subdomain and ensure CORS (already `*`).
   - Option B (Worker): serve `ui` via Wrangler Assets or add a static handler to `worker/src/index.ts`.
5. **Smoke tests**
   ```bash
   curl https://<worker-domain>/health
   curl https://<worker-domain>/api/rooms
   ```
6. **IoT simulator (prod)**
   ```bash
   INGEST_URL="https://<worker-domain>/api/iot/ingest" \
   DEVICE_ID="device-holo-01" \
   DEVICE_SECRET="DEVSECRET123" \
   python3 scripts/iot_sim.py
   ```
````

## File: sql/seed.sql
````sql
PRAGMA foreign_keys = OFF;
DELETE FROM users;
DELETE FROM rooms;
DELETE FROM room_members;
DELETE FROM messages;
DELETE FROM tasks;
DELETE FROM checkins;
DELETE FROM devices;
DELETE FROM readings;
DELETE FROM suggestions;
DELETE FROM events;
INSERT INTO users (id, email, pass_hash, role, created_at)
VALUES ('user-admin', 'admin@holo.work', 'pbkdf2$200000$kutwS1jQDWsYX0xQex7HSQ==$eMuaYN6F3q9ZAUVDt4U2JBDD7SxXkgkVlrJ12jFckO0=', 'admin', strftime('%s','now')*1000);
INSERT INTO rooms (id, name, slug, map_seed, created_at)
VALUES
  ('room-holo', 'Holo Hub', 'holo-hub', 'grid:16x16:hub', strftime('%s','now')*1000),
  ('room-lab', 'Lab Norte', 'lab-norte', 'grid:16x16:lab', strftime('%s','now')*1000);
INSERT INTO room_members (user_id, room_id, joined_at) VALUES
  ('user-admin', 'room-holo', strftime('%s','now')*1000),
  ('user-admin', 'room-lab', strftime('%s','now')*1000);
INSERT INTO devices (id, room_id, name, kind, secret_hash, created_at)
VALUES ('device-holo-01', 'room-holo', 'Env Beacon 01', 'environment', '92ae2a030fb7b169cf2612db1e8a4819fb03b9356f714be39c2a4ffe2d127f71', strftime('%s','now')*1000);
````

## File: README.md
````markdown
# holo.work

Workspace hub blending lightweight presence, chat, tasks, IoT comfort readings, and an agent that nudges healthier rhythms. Built for Cloudflare Workers + D1 + KV with zero heavy frameworks.

## Stack
- API: Cloudflare Worker (TypeScript) + D1 (SQLite) + KV for rate limiting + counters
- UI: Static HTML/CSS/ES modules served via Pages or worker static handler
- IoT: Python simulator posting telemetry (temp/noise/lux)
- Auth: PBKDF2-SHA256 password hashing (peppered) until Argon2id is wired through a bundled WASM module that plays nicely with Workers local dev

## Quickstart
1. Install deps: `npm install`
2. Create CF resources:
   ```bash
   npx wrangler d1 create holo_work
   npx wrangler kv namespace create KV
   ```
3. Apply schema + seed:
   ```bash
   npx wrangler d1 execute holo_work --file=sql/schema.sql
   npx wrangler d1 execute holo_work --file=sql/seed.sql
   ```
4. Secrets (use `dev-pepper` locally so the seeded admin hash matches; no secrets are logged anywhere):
   ```bash
   npx wrangler secret put JWT_SECRET
   npx wrangler secret put PEPPER # dev-pepper
   npx wrangler secret put ZAI_API_KEY # optional
   ```
   - Local dev: drop the same values into `worker/.dev.vars` so Miniflare picks them up.
5. Dev server: `npm run dev`
6. IoT sim (after ingest route ready):
   ```bash
   export INGEST_URL="http://127.0.0.1:8787/api/iot/ingest"
   export DEVICE_ID="dev-device"
   export DEVICE_SECRET="DEVSECRET123"
   python3 scripts/iot_sim.py
   ```

## Repo map
```
worker/   # CF worker source
ui/       # static pages + assets
sql/      # schema + seed
scripts/  # supporting tools (iot simulator)
docs/     # PRD, checklist, evidence scripts
```

## Status
Track ongoing build in `docs/todo.md`. Major changes recorded in `CHANGELOG.md`.

## Google Docs
https://docs.google.com/document/d/1F9tRff_lB-MnmA13ewMS0pY-iBQUIUU8DEj7wG71gXE/edit?tab=t.0#heading=h.5vb5hai8clmd

## Figma
#### arq
https://www.figma.com/board/RnpSFs6Rj2zN0iZb2tXIOD/holo.work-%E2%80%94-arquitetura?node-id=0-1&p=f&t=VWsvSS78qQ1gCTcg-0

#### flow
https://www.figma.com/board/NNopmsqV4eYfyfd5nySpRw/holo.work-%E2%80%94-fluxo-principal?node-id=0-1&p=f&t=iG38V2JQwoyfJE1M-0

#### iot_ingestion
https://www.figma.com/board/mylZk4aj3JyOLpGGkBRlSu/holo.work-%E2%80%94-ingest%C3%A3o-iot?node-id=0-1&p=f&t=2DMRjlxAXgXkMxgB-0

#### agent flow
https://www.figma.com/board/3xvZqC9J1M4GLaLdsNPxiQ/holo.work-%E2%80%94-agente--heur%C3%ADstica-v1-?node-id=0-1&p=f&t=vpBNqo9dF7BoIBS6-0

#### endpoints
https://www.figma.com/board/z6YClh3FALBOUO9w3RJStd/holo.work-%E2%80%94-endpoints?node-id=0-1&p=f&t=pnMyQjh6VPEO661z-0

#### states
https://www.figma.com/board/jNwcCSkh9w1BCVxbgYzbte/holo.work-%E2%80%94-estados-de-presen%C3%A7a?node-id=0-1&p=f&t=a47lx0mnsAQObMfl-0

#### deploy
https://www.figma.com/board/QAiEky9luSHOt6u4moFLea/holo.work-%E2%80%94-deploy?node-id=0-1&p=f&t=t7kQnDRCOIKkI5cD-0
````
